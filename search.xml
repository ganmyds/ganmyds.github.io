<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybaties总结]]></title>
    <url>%2Fmybaties_start.html</url>
    <content type="text"><![CDATA[为什么要使用mybaties由于jdbc有以下一些问题： 1、数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。2、Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。3、使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。4、对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 使用mybaties可以比较好的解决上面的问题 #####mybaties原理 mybatis配置1、SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。2、mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂3、由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。4、mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。5、Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。6、Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。7、Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 配置信息mybaties的核心配置文件是sqlMapConfig.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告诉Map的位置 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 所有的sql语句都写到配置文件里面去了 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 写sql语句 --&gt;&lt;mapper namespace="test"&gt; &lt;!-- 通过id查询用户 --&gt; &lt;select id="findUserById" parameterType="Integer" resultType="cn.itcast.mybatis.po.User" &gt; select * from user where id = #&#123;v&#125; &lt;/select&gt; &lt;!-- 通过username模糊查询 parameterType表示参数类型 resultType表示返回类型--&gt; &lt;select id="findUserByUserName" parameterType="String" resultType="cn.itcast.mybatis.po.User" &gt; &lt;!-- select * from user where username like '%$&#123;value&#125;%' 代替 这个时候一定要写value $&#123;value&#125;是连接符--&gt; select * from user where username like "%"#&#123;value&#125;"%" &lt;/select&gt;&lt;/mapper&gt; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package junit;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import cn.itcast.mybatis.po.User;public class MybatiesTest &#123; //根据id查询 public void testMybaties() throws Exception &#123; //加载核心配置文件 String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //执行Sql语句 10表示传到sql语句里面的参数 User user = sqlSession.selectOne("test.findUserById", 10); System.out.println(user); &#125; //模糊查询 @Test public void testMybatiesByName() throws Exception &#123; //加载核心配置文件 String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //执行Sql语句 List&lt;User&gt; users = sqlSession.selectList("test.findUserByUserName", "王"); for (User user : users) &#123; System.out.println(user); &#125; &#125;&#125; 注意：当返回是一个list的时候，使用selectList()方法查询，resultType表示的就是list的范型 添加用户12345678&lt;!-- 添加用户 --&gt;&lt;insert id="insertUser" &gt; &lt;selectKey resultType="Integer" order="AFTER" keyProperty="id"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into user (username, birthday, sex, address) values (#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;)&lt;/insert&gt; 123456789101112131415@Testpublic void testInsertUser() throws Exception &#123; //加载核心配置文件 String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User("何炅", "女", new Date(), "阳光大道18号"); //执行Sql语句 int index = sqlSession.insert("test.insertUser", user); sqlSession.commit(); System.out.println(user.getId()); ｝ 注意： LAST_INSERT_ID()是mysql提供的函数，表示最近增长的的数据的id，如果是mysql order要选择AFTER， oracle选择BEFORE， keyProperty表示放到对应的类的哪个属性里面 修改用户12345678910111213public void UpdateUserById() throws Exception &#123; //加载核心配置文件 String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(29, "何日火", "女", new Date(), "阳光大道18号"); //执行Sql语句 int index = sqlSession.update("test.updateUser", user); sqlSession.commit(); &#125; 123456&lt;!-- 更新用户 --&gt; &lt;update id="updateUser" parameterType="cn.itcast.mybatis.po.User"&gt; update user set username = #&#123;username&#125;, birthday = #&#123;birthday&#125;, sex = #&#123;sex&#125; where id = #&#123;id&#125; &lt;/update&gt; 删除用户123456789101112public void DelUserById() throws Exception &#123; //加载核心配置文件 String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); //创建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //创建SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //执行Sql语句 sqlSession.delete("test.deleteUserById", 28); sqlSession.commit(); &#125; 1234&lt;!-- 删除用户 --&gt; &lt;delete id="deleteUserById" parameterType="Integer"&gt; delete from user where id = #&#123;vvv&#125; &lt;/delete&gt; mybaties和hibernate的区别1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。 2、Mybatis学习门槛低，简单易学 3、程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，但需求变化要求成果输出迅速。 4、mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。 Mapper动态代理原则： 1、Mapper.xml文件中的namespace与mapper接口的完整类路径相同。2、Mapper接口方法名和Mapper.xml中定义的每个statement的id相同3、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同4、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 例如： 接口 12345public interface UserMapper &#123; public User findUserById(Integer id); &#125; UserMapper.xml 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- 写Sql语句 --&gt;&lt;mapper namespace="com.itheima.mybatis.mapper.UserMapper"&gt; &lt;!-- 通过ID查询一个用户 --&gt; &lt;select id="findUserById" parameterType="Integer" resultType="cn.itcast.mybatis.po.User"&gt; select * from user where id = #&#123;v&#125; &lt;/select&gt;&lt;/mapper&gt; 测试： 12345678910@Test public void testMapper() throws Exception &#123; String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findUserById(10); System.out.println(user); &#125; 小结： mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。 取别名可以在sqlMapConfig.xml里面设置别名，这样写sql语句的xml文件时就不需要写完整类名了，用别名即可 123&lt;typeAliases&gt; &lt;typeAlias type="cn.itcast.mybatis.po.User" alias="User"/&gt; &lt;/typeAliases&gt; 这是将cn.itcast.mybatis.po.User明确指定为User 123&lt;typeAliases&gt; &lt;package name="cn.itcast.mybatis.po"/&gt;&lt;/typeAliases&gt; 这是指定cn.itcast.mybatis.po这个包下面所有类名，例如cn.itcast.mybatis.po.User指定为user和User，一般最好指定的包名下面都是pojo类 映射器在mapper标签里面有三个属性，分别是resource、url、class 这三个属性只能出现一个，resource用法如下 123&lt;mappers&gt; &lt;mapper resource="com/itheima/mybatis/mapper/UserMapper.xml" /&gt;&lt;/mappers&gt; 使用mapper接口类路径 1&lt;mapper class="cn.itcast.mybatis.mapper.UserMapper"/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 url要用绝对路径，现在不用 使用package接口类路径 注册指定包下的所有mapper接口 1&lt;package name="cn.itcast.mybatis.mapper"/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。现在package用得多]]></content>
      <categories>
        <category>mybaties</category>
      </categories>
      <tags>
        <tag>mybaties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybaties进阶]]></title>
    <url>%2Fmybaties_imp.html</url>
    <content type="text"><![CDATA[传递pojo包装对象开发中通过可以使用pojo传递查询条件。查询条件可能是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如查询用户信息的时候，将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。包装对象：Pojo类中的一个属性是另外一个pojo。 需求：根据用户名模糊查询用户信息，查询条件放到QueryVo的user属性中。 创建QueryVo对象 1234567891011121314151617import java.io.Serializable;//对象从内存转换成二进制就是序列化，从二进制转回对象就是反系列化public class QueryVo implements Serializable&#123; private static final long serialVersionUID = 1L; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; UserMapper.xml 1234567&lt;mapper namespace="com.itheima.mybatis.mapper.UserMapper"&gt; &lt;!-- 根据用户名模糊查询 --&gt; &lt;select id="findUserByQueryVo" parameterType="QueryVo" resultType="User" &gt; &lt;!-- select * from user where username like '%$&#123;value&#125;%' --&gt; select * from user where username like "%"#&#123;user.username&#125;"%" &lt;/select&gt;&lt;/mapper&gt; UserMapper.java 1public List&lt;User&gt; findUserByQueryVo(QueryVo vo); test.java 12345678910111213141516@Test public void testMapper() throws Exception &#123; String resource = "sqlMapConfig.xml"; InputStream in = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); QueryVo queryVo = new QueryVo(); User user = new User(); user.setUsername("张"); queryVo.setUser(user); List&lt;User&gt; list = userMapper.findUserByQueryVo(queryVo); for (User u : list) &#123; System.out.println(u); &#125; &#125; resultMap手动映射一般来说pojo对象的属性要和数据库属性名保持一致，通过mybaties自动映射实现对应，但是如果表名和pojo属性名不一致的部分可以采取手动映射的方式 123456789&lt;mapper namespace="com.itheima.mybatis.mapper.OrdersMapper"&gt; &lt;resultMap type="Orders" id="Orders"&gt; &lt;result column="user_id" property="userId"/&gt; &lt;/resultMap&gt; &lt;!-- 查询所有的订单数据 --&gt; &lt;select id="queryOrderAll" resultMap="Orders"&gt; SELECT id, user_id, number, createtime, note FROM orders &lt;/select&gt;&lt;/mapper&gt; column表示表的属性，property表示pojo对象的属性，然后resultMap的值要和id的值保持一致 这个返回类型一定要注意，刚才类型写错了，找半天才找出来问题， 伤心 sql动态标签mybaties可以在sql里面添加逻辑判断 &lt;where&gt;标签可以去掉查询条件的第一个and，防止拼接sql语句出现语法错误 &lt;if&gt;标签可以做逻辑判断，例如下面的非空判断： 123456789101112&lt;!-- 根据性别和用户名查询数据 --&gt; &lt;select id="selectUserBySexAndUsername" parameterType="User" resultType="User"&gt; select * from user &lt;where&gt; &lt;if test="sex != null and sex != ''"&gt; sex = #&#123;sex&#125; and &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; username = #&#123;username&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;sql&gt;片断在mybaties里面，有一些重复的sql片断可以放到sql标签里面，方便引用，例如： 123456789101112131415&lt;sql id="selector"&gt; select * from user&lt;/sql&gt;&lt;!-- 根据性别和用户名查询数据 --&gt;&lt;select id="selectUserBySexAndUsername" parameterType="User" resultType="User"&gt; &lt;include refid="selector"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="sex != null and sex != ''"&gt; sex = #&#123;sex&#125; and &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; username = #&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;foreach&gt;标签可以对一个集合进行迭代解析出值，例如 12//根据多个id来查询用户public List&lt;User&gt; selectUserByIds(QueryVo vo); 12345678910111213141516&lt;!-- 根据多个id查询用户 --&gt;&lt;!-- foreach标签，进行遍历 --&gt;&lt;!-- collection：遍历的集合，这里是QueryVo的ids属性 --&gt;&lt;!-- item：遍历的项目，可以随便写，，但是和后面的#&#123;&#125;里面要一致 --&gt;&lt;!-- open：在前面添加的sql片段 --&gt;&lt;!-- close：在结尾处添加的sql片段 --&gt;&lt;!-- separator：指定遍历的元素之间使用的分隔符 --&gt;&lt;select id="selectUserByIds" parameterType="QueryVo" resultType="User"&gt; &lt;include refid="selector"&gt;&lt;/include&gt; &lt;where&gt; id in &lt;foreach collection="listKeys" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 也可以直接传一个计划或者数组进来 1234//根据多个id来查询用户public List&lt;User&gt; selectUserByIds(List&lt;Integer&gt; list);//根据多个id来查询用户public List&lt;User&gt; selectUserByIdss(Integer[] list); 1234567891011121314151617181920&lt;!-- 根据多个id查询用户 --&gt; &lt;select id="selectUserByIds" parameterType="List" resultType="User"&gt; &lt;include refid="selector"&gt;&lt;/include&gt; &lt;where&gt; id in &lt;foreach collection="list" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt;&lt;!-- 根据多个id查询用户 --&gt; &lt;select id="selectUserByIdss" parameterType="Integer[]" resultType="User"&gt; &lt;include refid="selector"&gt;&lt;/include&gt; &lt;where&gt; id in &lt;foreach collection="array" item="id" separator="," open="(" close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 注意collection的值首字母要小写]]></content>
      <categories>
        <category>mybaties</category>
      </categories>
      <tags>
        <tag>mybaties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh框架整合]]></title>
    <url>%2Fssh_start.html</url>
    <content type="text"><![CDATA[这段时间主要在看ssh，发现有了框架之后开发效率有了飞快的提升，尽管struts现在有的人很少了，但是ssh的思想依然值得学习，由于使用ssh整合，hibernate的hibernate.cfg.xml文件被spring接管，sessionFaction在spring配置文件里面配置即可。 先说一下hibernate和spring的整合 首先创建domain对象Employee 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.ganmy.domain;import java.util.Date;public class Employee &#123; private Integer id; private String name; private String email; private java.util.Date hiredate; private Float salary; public Employee()&#123;&#125;; public Employee(String name, String email, Date hiredate, Float salary) &#123; this.name = name; this.email = email; this.hiredate = hiredate; this.salary = salary; &#125; public Employee(Integer id, String name, String email, Date hiredate,Float salary) &#123; this.id = id; this.name = name; this.email = email; this.hiredate = hiredate; this.salary = salary; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public java.util.Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(java.util.Date hiredate) &#123; this.hiredate = hiredate; &#125; public Float getSalary() &#123; return salary; &#125; public void setSalary(Float salary) &#123; this.salary = salary; &#125;&#125; 配置对应的hbm文件 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping package="com.ganmy.domain"&gt; &lt;class name="Employee" table="employee" lazy="false"&gt; &lt;!-- id元素用于指定主键属性 --&gt; &lt;id name="id" column="id" type="java.lang.Integer"&gt; &lt;!-- generator用于指定主键值生成的策略 使用native策略 "assigned策略表示可以指定id" --&gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 除了主键的其他属性 --&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" not-null="false" length="64"/&gt; &lt;/property&gt; &lt;property name="email" type="java.lang.String"&gt; &lt;column name="email" not-null="false" length="64" /&gt; &lt;/property&gt; &lt;property name="hiredate" type="java.util.Date"&gt; &lt;column name="hiredate" not-null="false" /&gt; &lt;/property&gt; &lt;property name="salary" type="java.lang.Float"&gt; &lt;column name="salary" not-null="false" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在数据库中创建对应的数据库表，创建service和serviceinterface包，创建对应的接口和实现接口的service类 1234567891011121314151617181920package com.ganmy.service.interfaces;import java.util.List;import com.ganmy.domain.Employee;public interface EmployeeServiceInt &#123; //声明保存雇员的方法 public void addEmployee(Employee e); //显示所有雇员 public List&lt;Employee&gt; showEmployee(); //更新雇员 public void updateEmployee(Employee e); //根据id号删除雇员,由于int和float都实现了Serializable这个接口，使用Serializable更加通用 public void deleteEmployee(java.io.Serializable id);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.ganmy.service.imp;import java.io.Serializable;import java.util.List;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.springframework.transaction.annotation.Transactional;import com.ganmy.domain.Employee;import com.ganmy.service.interfaces.EmployeeServiceInt;//这里配置注解@Transactional，用处是让spring的事务管理器接管该service的所有事务//这个注解放在类上面就对整个类生效，放在方法上面就对整个方法生效@Transactionalpublic class EmployeeService implements EmployeeServiceInt&#123; private SessionFactory sessionFactory; public SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; public void addEmployee(Employee e) &#123;// Session session = sessionFactory.openSession();// Transaction tx = (Transaction) session.beginTransaction();// session.save(e);// tx.commit(); sessionFactory.getCurrentSession().save(e); &#125; public void deleteEmployee(Serializable id) &#123; &#125; public List&lt;Employee&gt; showEmployee() &#123; return null; &#125; public void updateEmployee(Employee e) &#123; &#125;&#125; 到这里基本工作就完成了，由于hibernate.cfg.xml被整合到spring里面，接下来配置ApplicationContext.xml文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" &gt; &lt;!-- 配置测试类 --&gt; &lt;bean id="testService" class="com.ganmy.test.TestService"&gt; &lt;property name="name"&gt; &lt;value&gt;明阳&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;!-- 配置databaseSource --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/users?useUnicode=true&amp;amp;characterEncoding=utf-8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;!-- 连接池启动时的初始值 --&gt; &lt;property name="initialSize" value="3"/&gt; &lt;!-- 连接池的最大值 --&gt; &lt;property name="maxActive" value="500"/&gt; &lt;!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt; &lt;property name="maxIdle" value="2"/&gt; &lt;!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt; &lt;property name="minIdle" value="1"/&gt; &lt;/bean&gt; &lt;!-- 配置sessionFactory --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt; &lt;!-- 设置数据元 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!-- 接管hibernate里面的对象关系映射文件 --&gt; &lt;property name="mappingResources"&gt; &lt;list&gt; &lt;value&gt;com/ganmy/domain/Employee.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;value&gt; hibernate.dialect=org.hibernate.dialect.MySQLDialect hibernate.hbm2ddl.auto=update hibernate.show_sql=true hibernate.format_sql=true hibernate.cache.use_second_level_cache=true hibernate.cache.provider_class=org.hibernate.cache.EhCacheProvider hibernate.generate_statistics=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置service --&gt; &lt;bean id="employeeService" class="com.ganmy.service.imp.EmployeeService"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 ,统一管理sessionFactory的事务--&gt; &lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory"/&gt; &lt;/bean&gt; &lt;!-- 启用事务的注解 --&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt;&lt;/beans&gt; #####数据源的概念： 1、初始值，连接池默认开始的连接数量，可以瞬间使用，不需要建立驱动的连接 2、最大值，是对数据库的保护机制，比如最大值为500时，当第501个连接来了就会等待，如果前面的连接释放了才会去连接 3、最大空闲值，当经过一段时间后，连接池会慢慢释放一部分连接，比如上面的配置会释放到2个连接 4、最小空闲值，如上面，一共500个连接，当用499个连接被使用的时候，连接池会去创建连接，防止来不及申请 测试：1234567891011121314151617package com.ganmy.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.ganmy.domain.Employee;import com.ganmy.service.interfaces.EmployeeServiceInt;public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); Employee emp = new Employee("aa111", "1535628743@qq.com", new java.util.Date(),23.456f); EmployeeServiceInt es = (EmployeeServiceInt) ac.getBean("employeeService"); es.addEmployee(emp); &#125;&#125; 配置struts struts-config.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE struts-config PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 1.3//EN" "http://struts.apache.org/dtds/struts-config_1_3.dtd"&gt;&lt;struts-config&gt; &lt;form-beans&gt; &lt;form-bean name="employeeForm" type="com.ganmy.web.forms.EmployeeForm"/&gt; &lt;/form-beans&gt; &lt;action-mappings&gt; &lt;action path="/login" parameter="flag" name="employeeForm"&gt; &lt;forward name="ok" path="/WEB-INF/MainFrame.jsp" /&gt; &lt;forward name="err" path="/WEB-INF/login.jsp" /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;!-- 配置代理请求处理 DelegatingRequestProcessor ,它的用处是可以让spring来获取strut的action信息和配置action的一些属性--&gt; &lt;controller&gt; &lt;set-property property="processorClass" value="org.springframework.web.struts.DelegatingRequestProcessor"/&gt; &lt;/controller&gt; &lt;/struts-config&gt; web.xml 123456789&lt;!-- 相对src目录寻找的 ，tomcat启动的时候会去实例化spring容器，applicationContext.xml配置的bean对象都实例化了--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- 对Spring容器进行实例化 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; applicationContext.xml 1234&lt;!-- 配置action --&gt; &lt;bean name="/login" class="com.ganmy.web.action.LoginAction" scope="prototype"&gt; &lt;property name="employeeServiceInt" ref="employeeService"/&gt; &lt;/bean&gt; 解决中文乱码问题： 1、自己配置过滤器 创建com.ganmy.web.filter包，创建一个servlet名为MyFilter实现javax.servlet.Filter这个接口 内容： 12arg0.setCharacterEncoding("utf-8");//设置接收编码arg2.doFilter(arg0, arg1);//必须要有，如果没有会停止前进 在web.xml里面添加 12345678&lt;filter&gt; &lt;filter-name&gt;Myfilter&lt;/filter-name&gt; &lt;filter-class&gt;com.ganmy.web.filter.Myfilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Myfilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2、使用spring提供的过滤器 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 使用注解的方式配置属性分三步： 1、配置bean，不用注入属性 1&lt;bean id="employeeService" class="com.ganmy.service.imp.EmployeeService"/&gt; 3、在对应的属性sessionFactory上方添加注解 123//当我们给某个属性增加了resource后,spring就会启动byName的方式注入属性值@Resourceprivate SessionFactory sessionFactory; 3、启用注解扫描 1&lt;context:annotation-config/&gt; 是使用byName的方式匹配的，由于创建对象的时候这个属性指向null，于是就在配置文件里面的bean里面找一个id和这个name相同的对象指向给这个属性，这就是byName的方式 懒加载的问题ssh整合的时候如何解决懒加载的问题，比如有多张表关联，对象对于外部关联的表会遇到懒加载的情况，解决方案： 1、显示初始化 1234//显示初始化，防止懒加载Hibernate.initialize(Department.class);//但是要先打印才行System.out.println(ee.getDepartment().getName()); 2、在配置文件里面添加lazy=”false” 但是这两种方法不好，不管jsp用不用都会向数据库查询，最好是让session的生命周期变长一点 3、spring专门提供的方法opensessioninview，需要在web文件中添加一个过滤器，原理是延缓了commit的时间 123456789&lt;!-- 配置opensessioninview解决懒加载,本质一个过滤器. --&gt;&lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate3.support.OpenSessionInViewFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 该方法可以减少使用sql的次数，缺点是会延长和数据库保持的session的生命周期 基础接口通过在web层和业务层添加一层基础接口BasicService来提高代码的复用性，简单的说就是将所有service里面的通用的方法写到基础接口里面，然后通过继承的方式来获取这些方法，然后自己独特的方法就放到自己的接口里面，然后实现这个接口 注意spring的注解扫描和很多配置信息都是在服务器启动的时候注入的，也就是说项目一定要和tomcat关联，在启动tomcat的时候加载配置信息，不然这些配置信息都用不了。 struts一个actio跳到另一个action方法通过struts-config.xml跳转 1return mapping.findForward("pageTurn"); 1&lt;forward name="pageTurn" path="/user.do?flag=pageTurn" /&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jstl标签的使用]]></title>
    <url>%2Fjstl_start.html</url>
    <content type="text"><![CDATA[jstl全称jsp standard tag library，翻译成中文就是jsp标准标签库。由于jsp文件中有大量的java片段会让文件变得很混乱，于是使用jstl标签替换这些java片段。可以让代码变得更加简洁且提高开发速度。下面详细介绍： &lt;c:out&gt;标签引用1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%&gt; 基本使用作用是用来输入信息的，例如下面输入hello world： 1&lt;c:out value="hello world"&gt;&lt;/c:out&gt; 域对象变量1&lt;c:out value="$&#123;abc&#125;" default="没找到值"&gt;&lt;/c:out&gt; 如果有四个域对象里面都有相同的变量，那么优先级是： pageContext &gt; request &gt; session &gt; application 并且如果在在域对象里面找不到对应的变量名则会打印default的值，也可以输出对象，同时也可以用el表达式替换，例如 1&lt;c:out value="$&#123;user1.name&#125;"&gt;&lt;/c:out&gt; 等同于 1$&#123;user1.name&#125; escapeXmlescapeXml属性表示是否解析跳过html标签，默认值为true 1pageContext.setAttribute("abc","你好1&lt;h1&gt;哈哈&lt;/h1&gt;"); 1&lt;c:out value="$&#123;abc&#125;" default="没找到值" escapeXml="false"&gt;&lt;/c:out&gt; &lt;c:set&gt;标签用来设置属性，和&lt;c:out&gt;标签差不多的用法 例如： 1&lt;c:set var="abc" value="行号" scope="request"&gt;&lt;/c:set&gt; 等同于： 1request.setAttribute("abc","行号"); &lt;c:remove&gt;标签用来删除属性的 1&lt;c:remove var="abc" scope="session" /&gt; 表示在session作用域里面删除变量abc，如果不写scope则会在所有作用域里面删除abc &lt;c:catch&gt;标签用来抛异常的，例如： 1234&lt;c:catch var="exception"&gt; &lt;%int i = 9/0; %&gt;&lt;/c:catch&gt;&lt;c:out value="$&#123;exception.message&#125;"&gt;&lt;/c:out&gt; &lt;c:if&gt;标签单分支判断，例如： 123456789&lt;% User u = new User(); u.setName("小明"); u.setAge(30); request.setAttribute("user1", u);%&gt;&lt;c:if test="$&#123;user1.name=='小明'&#125;"&gt; 测试通过&lt;/c:if&gt; &lt;c:choose&gt;标签多分支判断 1234567891011121314151617&lt;% User u = new User(); u.setName("小明"); u.setAge(40); request.setAttribute("user1", u);%&gt;&lt;c:choose&gt; &lt;c:when test="$&#123;user1.age &lt; 32&#125;"&gt; 年龄小于32岁 &lt;/c:when&gt; &lt;c:when test="$&#123;user1.age &lt; 50&#125;"&gt; 年龄小于50岁 &lt;/c:when&gt; &lt;c:otherwise&gt; 年龄大于50岁 &lt;/c:otherwise&gt;&lt;/c:choose&gt; &lt;c:forEach&gt;标签替换foreach12345678910111213141516&lt;% ArrayList&lt;User&gt; list = new ArrayList&lt;User&gt;(); User u = new User("小明",40); User u1 = new User("历史",20); User u2 = new User("小红",18); User u3 = new User("小李",30); list.add(u); list.add(u1); list.add(u2); list.add(u3); request.setAttribute("list", list);%&gt;&lt;c:forEach items="$&#123;list&#125;" var="user"&gt; &lt;c:out value="$&#123;user.name&#125;"&gt;&lt;/c:out&gt; &lt;c:out value="$&#123;user.age&#125;"&gt;&lt;/c:out&gt;&lt;/c:forEach&gt; items表示去迭代的变量，相当于下面的list1，var表示迭代后赋值的变量，相当于下面的user2 123for(User user2: list1)&#123; System.out.println(user2.getName() + "," + user2.getAge()); &#125; 替换普通for循环例如打印1到10 123&lt;c:forEach var="i" begin="1" end="10"&gt; &lt;c:out value="$&#123;i&#125;"&gt;&lt;/c:out&gt;&lt;/c:forEach&gt; 可以间隔打印，指定step属性，例如下面打印1到10的所有奇数 123&lt;c:forEach var="i" begin="1" end="10" step="2"&gt; &lt;c:out value="$&#123;i&#125;"&gt;&lt;/c:out&gt;&lt;/c:forEach&gt; &lt;c:forTokens&gt;标签用来拆分字符串的，items表示目标字符串，delims表示根据什么来拆分，var表示拆分出来的字段， 例如： 123&lt;c:forTokens items="12;56;78;你好" delims=";" var="temp"&gt; $&#123;temp&#125;&lt;/c:forTokens&gt; 在jstl标签里面使用el表达式是非常重要的，在el表达式里面判断某个变量是否为null或者””或者{}都可以用 empty 变量的形式来判断，而且el表达式可以获取a标签传过去的参数，例如${param.id}就是获取上个页面传过来的id &lt;c:fn&gt;标签el表达式也支持函数的使用，不过需要引用jstl函数库，不然会报错，下面是一个拆分手机号码的例子： 123&lt;!-- 引入jstl函数库 --&gt;&lt;%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions"%&gt;&lt;div class="m_t10 style_dan"&gt;手机号：&lt;span&gt;$&#123;fn:substring(user.phone, 0,3) &#125;****$&#123;fn:substring(user.phone, 7, 11) &#125;&lt;/span&gt;&lt;/div&gt; &lt;fmt:formatDate&gt;jsp页面时间格式化显示使用 123456789101112131415161718192021222324252627282930313233&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;JSTL fmt:dateNumber 标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;日期格式化:&lt;/h3&gt;&lt;c:set var="now" value="&lt;%=new java.util.Date()%&gt;" /&gt;&lt;p&gt;日期格式化 (1): &lt;fmt:formatDate type="time" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (2): &lt;fmt:formatDate type="date" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (3): &lt;fmt:formatDate type="both" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (4): &lt;fmt:formatDate type="both" dateStyle="short" timeStyle="short" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (5): &lt;fmt:formatDate type="both" dateStyle="medium" timeStyle="medium" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (6): &lt;fmt:formatDate type="both" dateStyle="long" timeStyle="long" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;p&gt;日期格式化 (7): &lt;fmt:formatDate pattern="yyyy-MM-dd" value="$&#123;now&#125;" /&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 界面显示 123456789101112131415日期格式化:日期格式化 (1): 11:19:43日期格式化 (2): 2016-6-26日期格式化 (3): 2016-6-26 11:19:43日期格式化 (4): 16-6-26 上午11:19日期格式化 (5): 2016-6-26 11:19:43日期格式化 (6): 2016年6月26日 上午11时19分43秒日期格式化 (7): 2016-06-26 下面是所有函数表格 函数名 函数说明 使用举例 fn:contains 判断字符串是否包含另外一个字符串 &lt;c:if test=&quot;${fn:contains(name, searchString)}&quot;&gt; fn:containsIgnoreCase 判断字符串是否包含另外一个字符串(大小写无关) &lt;c:if test=&quot;${fn:containsIgnoreCase(name, searchString)}&quot;&gt; fn:endsWith 判断字符串是否以另外字符串结束 &lt;c:if test=&quot;${fn:endsWith(filename, &quot;.txt&quot;)}&quot;&gt; fn:escapeXml 把一些字符转成XML表示，例如&lt;字符应该转为&lt; ${fn:escapeXml(param:info)} fn:indexOf 子字符串在母字符串中出现的位置 ${fn:indexOf(name, “-“)} fn:join 将数组中的数据联合成一个新字符串，并使用指定字符格开 ${fn:join(array, “;”)} fn:length 获取字符串的长度，或者数组的大小 ${fn:length(shoppingCart.products)} fn:replace 替换字符串中指定的字符 ${fn:replace(text, “-“, “&#149;”)} fn:split 把字符串按照指定字符切分 ${fn:split(customerNames, “;”)} fn:startsWith 判断字符串是否以某个子串开始 &lt;c:if test=&quot;${fn:startsWith(product.id, &quot;100-&quot;)}&quot;&gt; fn:substring 获取子串 ${fn:substring(zip, 6, -1)} fn:substringAfter 获取从某个字符所在位置开始的子串 ${fn:substringAfter(zip, “-“)} fn:substringBefore 获取从开始到某个字符所在位置的子串 ${fn:substringBefore(zip, “-“)} fn:toLowerCase 转为小写 ${fn.toLowerCase(product.name)} fn:toUpperCase 转为大写字符 ${fn.UpperCase(product.name)} fn:trim 去除字符串前后的空格 ${fn.trim(name)} 函数 描述 fn:contains(string, substring) 如果参数string中包含参数substring，返回true fn:containsIgnoreCase(string, substring) 如果参数string中包含参数substring（忽略大小写），返回true fn:endsWith(string, suffix) 如果参数 string 以参数suffix结尾，返回true fn:escapeXml(string) 将有特殊意义的XML (和HTML)转换为对应的XML character entity code，并返回 fn:indexOf(string, substring) 返回参数substring在参数string中第一次出现的位置 fn:join(array, separator) 将一个给定的数组array用给定的间隔符separator串在一起，组成一个新的字符串并返回。 fn:length(item) 返回参数item中包含元素的数量。参数Item类型是数组、collection或者String。如果是String类型,返回值是String中的字符数。 fn:replace(string, before, after) 返回一个String对象。用参数after字符串替换参数string中所有出现参数before字符串的地方，并返回替换后的结果 fn:split(string, separator) 返回一个数组，以参数separator 为分割符分割参数string，分割后的每一部分就是数组的一个元素 fn:startsWith(string, prefix) 如果参数string以参数prefix开头，返回true fn:substring(string, begin, end) 返回参数string部分字符串, 从参数begin开始到参数end位置，包括end位置的字符 fn:substringAfter(string, substring) 返回参数substring在参数string中后面的那一部分字符串 fn:substringBefore(string, substring) 返回参数substring在参数string中前面的那一部分字符串 fn:toLowerCase(string) 将参数string所有的字符变为小写，并将其返回 fn:toUpperCase(string) 将参数string所有的字符变为大写，并将其返回 fn:trim(string) 去除参数string 首尾的空格，并将其返回 在jsp页面里面最好不要出现java代码块，但是那个&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;我一直有点头疼，最近终于找到替换方案了，如下： 1&lt;base href="$&#123;pageContext.request.scheme&#125;://$&#123;pageContext.request.serverName&#125;:$&#123;pageContext.request.serverPort&#125;$&#123;pageContext.request.contextPath&#125;/"&gt; 使用el表达式解决设置base出现的相对路径的问题 ${pageContext.request.contextPath}用于解决使用相对路径时出现的问题，它的作用是取出所部署项目的名字。 ${pageContext.request.contextPath}返回的是”/test”【注意：很多地方写的返回值是“test/”，这是不对的】，拼接之后路径就变成：/test/bookcover/101.jpg。]]></content>
      <categories>
        <category>jstl</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于spring的bean的理解]]></title>
    <url>%2Fspring_ioc.html</url>
    <content type="text"><![CDATA[获取bean的三种方法1、从applicationContext(应用上下文容器)中获取bean： ​ 如果bean的配置是singleton(默认值)，那么调用new ClassPathXmlApplicationContext()的时候，不管有没有getbean都会将对象实例化 2、从beanFactory中获取： 12BeanFactory bf = new XmlBeanFactory(new ClassPathResource("com/ganmy/ioc/beans.xml"));Student s = (Student) bf.getBean("student"); 创建BeanFactory的时候，配置文件里面的bean不会被实例化，只有当我们get某个bean的时候才会实例化这个对象，有点像hibernate里面的lazyload，然后在结合单例模式的创建，用户体验更好，缺点是耗内存 一般情况都是使用第一种方法获取bean，因为这样程序的速度比较快，如果是在移动设备使用的情况才会考虑使用BeanFactory创建，可以减少一点内存的使用，缺点是用户体验没有第一种好 3、XmlWebApplicationContext()，从web应用上下文中载入定义文件 获取ApplicationContext的三种方法1、ClassPathXmlApplicationContext()适用于桌面开发，通过类路径来加载 2、FileSystemXmlApplicationContext()通过文件路径来加载的，只能是绝对路径，例如： 1ApplicationContext ac = new FileSystemXmlApplicationContext("E:\\xiangmu\\myspring\\src\\com\\ganmy\\ioc\\beans.xml"); 3、XmlWebApplicationContext()，从web系统加载，当tomcat启动的时候就会去加载，在web中用的比较多。 bean的生命周期1、实例化，当我们的程序加载beans.xml文件的时候就开始实例化到内存中，前提是scope为singleton 2、调用set方法注入属性 3、如果该class实现了BeanNameAware接口，那么会调用setBeanName()方法，我们可以通过setBeanName()获取id号 4、如果实现了BeanFactoryAware接口，我们就可以通过setBeanFactory()方法获取BeanFactory 5、如果实现了ApplicationContextAware接口，我们就可以通过setApplicationContext()获取ApplicationContext 6、如果bean与一个后置处理器关联了，则会自动调用后缀处理器的postProcessBeforeInitialization()方法，postProcessAfterInitialization()暂时还不执行 7、如果实现了InitializingBean接口，那么就会调用afterPropertiesSet()方法 8、如果bean里面配置了init-method，则可以在bean中定义自己的初始化方法 9、如果与后置处理器管理才调用postProcessAfterInitialization()方法 10、使用我们的bean对象 11、spring容器关闭 12、通过实现DisposableBean接口来调用destory方法，这个方法和postProcessAfterInitialization()相对应 13、可以在beans.xml里面给bean配置destroy-method=”xxx()”调用我们定制的方法 下面是一个比较全面的例子，我们可以根据打印的顺序来判断执行过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.ganmy.beanlife;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.BeanFactoryAware;import org.springframework.beans.factory.BeanNameAware;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class PersionService implements BeanNameAware,BeanFactoryAware,ApplicationContextAware,InitializingBean&#123; private String name; public PersionService()&#123; System.out.println("构造方法被调用"); &#125;; public PersionService(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; System.out.println("setName()被调用"); this.name = name; &#125; public void sayHi()&#123; System.out.println("hi"+name); &#125; //该方法可以传送正在被实例化的id的值 public void setBeanName(String arg0) &#123; System.out.println("setBeanName()被调用，值是"+arg0); &#125; //可以传递beanFactory public void setBeanFactory(BeanFactory arg0) throws BeansException &#123; // TODO Auto-generated method stub System.out.println("setBeanFactory()被调用"+arg0); &#125; //可以调用ApplicationContext public void setApplicationContext(ApplicationContext arg0) throws BeansException &#123; // TODO Auto-generated method stub System.out.println("setApplicationContext()被调用"+arg0); &#125; @Override public void afterPropertiesSet() throws Exception &#123; // TODO Auto-generated method stub System.out.println("afterPropertiesSet()被调用"); &#125; public void init()&#123; System.out.println("我自己的init方法"); &#125; //bean销毁的时候调用的// public void destroy() throws Exception &#123;// // TODO Auto-generated method stub// //我们可以去关闭数据连接,socket，释放改bean占用的资源// &#125; //定制我们的销毁方法 public void mydestory()&#123; System.out.println("释放各种资源"); &#125;&#125; beans.xml文件 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;bean id="persionService" scope="prototype" init-method="init" destroy-method="mydestory" class="com.ganmy.beanlife.PersionService"&gt; &lt;property name="name" value="小明" /&gt; &lt;/bean&gt; &lt;bean id="persionService2" scope="prototype" class="com.ganmy.beanlife.PersionService"&gt; &lt;property name="name" value="小明" /&gt; &lt;/bean&gt; &lt;!-- 配置我们的后置处理器，有点类似Fileter --&gt; &lt;bean id="myBeanPostProcessor" class="com.ganmy.beanlife.MyBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 后置处理器 12345678910111213141516171819202122232425262728package com.ganmy.beanlife;import java.util.Date;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessAfterInitialization(Object arg0, String arg1) throws BeansException &#123; // TODO Auto-generated method stub System.out.println("postProcessAfterInitialization()函数被调用"); System.out.println(arg0+"被调用的时间是"+new Date()); return arg0; &#125; @Override public Object postProcessBeforeInitialization(Object arg0, String arg1) throws BeansException &#123; // TODO Auto-generated method stub System.out.println("postProcessBeforeInitialization()被调用"); System.out.println(arg0+"被调用的时间是"+new Date()); return arg0; &#125;&#125; 结果： 小结：在实际开发中往往没有用到这么多的过程，常见的过程是1、2、6、9、10、11 图解： beanFactory生命周期我们将ApplicationContext对象的创建方式改为XmlBeanFactory()的方式创建，结果如图所示： 和上图相比，少了3步，分别是ApplicationContext对象的创建、后置处理器的创建(before()和after())，那个打印的时间是在before()和after()里面打印的，用于判断执行的持续时间 图解： AOPAOP是Aspect Oriented Programming的缩写，翻译就是面向切面编程，在spring里面很好的体现了这种思想，例如我们使用后置处理器的时候，所有的bean都会进入postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法AOP是面向所有或者一类对象编程，核心是在不增加代码的基础上还增加相应功能的一种编程思想，AOP在开发框架本身用得多，在实际项目中用的不多，但是AOP用得越来越多是一个趋势，AOP是通过代理对象来实现的。 spring有两种代理方式 一、目标对象实现了某些接口，spring用JDK的java.lang.reflect.Proxy类代理，让spring动态产生一个新类，他实现所需的接口，织入通知，可以调用被代理对象的所有函数，获取的动态代理对象类型不是Proxy类而是被代理对象的类型 下面是一个比较全面的代理对象例子，两个接口： 123456789package com.ganmy.aop;public interface TestServiceInter &#123; public void sayHello(); public void sayGo();&#125; 123456package com.ganmy.aop;public interface TestServiceInter2 &#123; public void sayBye();&#125; 实现这两个接口的对象Test1Service 1234567891011121314151617181920212223242526272829package com.ganmy.aop;public class Test1Service implements TestServiceInter,TestServiceInter2 &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void sayHello() &#123; System.out.println("h1"+name); &#125; public void sayBye() &#123; System.out.println("Bye"+name); &#125; public void sayGo() &#123; System.out.println("Go"+name); &#125;&#125; 前置通知对象 12345678910111213141516171819package com.ganmy.aop;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;public class MyMethodBeforeAdvice implements MethodBeforeAdvice &#123; /** * method: 被调用方法名，调用的被代理对象的方法名 * args: 被代理对象方法的参数 * target: 被代理对象 */ public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("记录日志"+method.getName()); &#125;&#125; 配置文件beans.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" &gt; &lt;!-- 配置被代理的对象 --&gt; &lt;bean id="test1Service" class="com.ganmy.aop.Test1Service"&gt; &lt;property name="name" value="明阳"/&gt; &lt;/bean&gt; &lt;!-- 配置前置通知 --&gt; &lt;bean id="myMethodBeforeAdvice" class="com.ganmy.aop.MyMethodBeforeAdvice"&gt; &lt;/bean&gt; &lt;!-- 配置代理对象,将被代理对象和通知联系起来 --&gt; &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;!-- 配置代理接口集，这个name不能写错，一定要是proxyInterfaces，因为会调用相应的get和set方法 --&gt; &lt;property name="proxyInterfaces"&gt; &lt;!-- 由于可能代理多个接口，所以用list列起来 --&gt; &lt;list&gt; &lt;value&gt;com.ganmy.aop.TestServiceInter&lt;/value&gt; &lt;value&gt;com.ganmy.aop.TestServiceInter2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 把通知织入到代理对象 --&gt; &lt;property name="interceptorNames"&gt; &lt;!-- 把myMethodBeforeAdvice前置通知和代理对象关联起来 ，我们也可以把通知看成拦截器--&gt; &lt;value&gt;myMethodBeforeAdvice&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定被代理对象--&gt; &lt;property name="target" ref="test1Service"/&gt; &lt;/bean&gt;&lt;/beans&gt; 下面是一个比较全面的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" &gt; &lt;!-- 配置被代理的对象 --&gt; &lt;bean id="test1Service" class="com.ganmy.aop.Test1Service"&gt; &lt;property name="name" value="明阳"/&gt; &lt;/bean&gt; &lt;!-- 配置前置通知 --&gt; &lt;bean id="myMethodBeforeAdvice" class="com.ganmy.aop.MyMethodBeforeAdvice"&gt; &lt;/bean&gt; &lt;!-- 配置后置通知 --&gt; &lt;bean id="myAfterReturningAdvice" class="com.ganmy.aop.MyAfterReturningAdvice"&gt; &lt;/bean&gt; &lt;!-- 配置环绕通知 --&gt; &lt;bean id="myMethodInterceptor" class="com.ganmy.aop.MyMethodInterceptor"&gt; &lt;/bean&gt; &lt;!-- 配置异常通知 --&gt; &lt;bean id="myThrowsAdvice" class="com.ganmy.aop.MyThrowsAdvice"&gt; &lt;/bean&gt; &lt;!-- 选择某些函数不通知 --&gt; &lt;bean id="MyMethodBeforeAdviceFilter" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor"&gt; &lt;!-- 指向myMethodBeforeAdvice，表示对这个通知起作用 --&gt; &lt;property name="advice" ref="myMethodBeforeAdvice"/&gt; &lt;property name="mappedNames"&gt; &lt;!-- 设置哪些函数可以使用前置通知 ，可以使用正则表达式来匹配,例如say*表示匹配所有函数say的方法--&gt; &lt;list&gt; &lt;value&gt;sayGo&lt;/value&gt; &lt;!-- &lt;value&gt;say*&lt;/value&gt; --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置代理对象,将被代理对象和通知联系起来 --&gt; &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;!-- 配置代理接口集 --&gt; &lt;property name="proxyInterfaces"&gt; &lt;!-- 由于可能代理多个接口，所以用list列起来 --&gt; &lt;list&gt; &lt;value&gt;com.ganmy.aop.TestServiceInter&lt;/value&gt; &lt;value&gt;com.ganmy.aop.TestServiceInter2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 把通知织入到代理对象 --&gt; &lt;property name="interceptorNames"&gt; &lt;!-- 把myMethodBeforeAdvice前置通知和代理对象关联起来 ，我们也可以把通知看成拦截器--&gt; &lt;list&gt; &lt;!-- 织入前置通知,使用自定义切入点来控制前置通知 --&gt; &lt;value&gt;MyMethodBeforeAdviceFilter&lt;/value&gt; &lt;!-- 织入后置通知 --&gt; &lt;value&gt;myAfterReturningAdvice&lt;/value&gt; &lt;!-- 织入环绕通知 --&gt; &lt;value&gt;myMethodInterceptor&lt;/value&gt; &lt;!-- 织入异常通知 --&gt; &lt;value&gt;myThrowsAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 指定被代理对象--&gt; &lt;property name="target" ref="test1Service"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试文件 12345678910111213141516171819package com.ganmy.aop;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App1 &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("com/ganmy/aop/beans.xml"); TestServiceInter ts = (TestServiceInter) ac.getBean("proxyFactoryBean"); ts.sayHello(); System.out.println("*******过渡方法**********");// TestServiceInter2 ts2 = (TestServiceInter2) ac.getBean("proxyFactoryBean");// ts2.sayBye(); //更加简洁的转换 ((TestServiceInter2)ts).sayBye(); System.out.println("*******过渡**********"); ts.sayGo(); &#125;&#125; 代理对象实现了代理接口集，通知被织入代理对象，所以我们调用的代理对象转换为对应接口类型就可以调用相应的方法了，代理接口集的所有方法都会被织入前置通知。 连接点和织入点的关系，通知没有调用的时候是连接点(静态)，通知调用后就变成织入点了(动态) 通知一共有五种接口，根据功能不同区分的： 1、前置通知：MethodBeforeAdvice 1234567891011/** * method: 被调用方法名 * args: 给方法传递的参数 * target: 目标对象 */ public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("**********************"); System.out.println("记录日志"+method.getName()+","+args.length+","+target); &#125; 2、后置通知：AfterReturningAdvice 1234567891011/** * returnValue表示返回值 * method表示被代理对象被调用的方法 * args表示被代理对象的被调用方法的参数 * target表示表示被代理对象 */ public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("关闭资源"); &#125; 3、环绕通知：MyMethodInterceptor，环绕通知在前置通知后开始调用，可以在方法执行前和方法执行后调用，一定要执行arg0.proceed()的方法并且返回一个object对象，否则就不会进入方法 123456public Object invoke(MethodInvocation arg0) throws Throwable &#123; System.out.println("调用方法前执行"); Object obj = arg0.proceed(); System.out.println("调用方法后执行"); return obj; &#125; 4、异常通知：MyThrowsAdvice，异常通知在被代理对象的方法出现异常的时候调用 12345678910111213public class MyThrowsAdvice implements ThrowsAdvice &#123; /** * @param m表示出现异常的方法名 * @param os表示出现异常的参数 * @param target表示被代理对象 * @param e表示出现的异常名称 */ public void afterThrowing(Method m, Object[] os, Object target, Exception e )&#123; System.out.println("出现异常了" + e.getMessage()); &#125;&#125; 5、引入通知：不是一个独立的通知，是在beans.xml文件里面通过包装其他的通知来作用对象的，可以看上面的配置文件，另外配置的各种通知可以使用正则匹配。 二、目标对象没有实现任何接口，spring使用CGLIB生成目标对象的子类 注解一般写在某个方法上面用来指定这个方法在bean的生命周期的什么步骤执行，例如： @PostConstruct表示在init-method的时候执行 @PreDestroy表示在destory-method的时候执行 注解写起来很方便，但是如果我想要改动业务逻辑还是得到代码里面去改，达不到解耦的目的，感觉有些情况下没有写在配置文件里面好 装配bean实际上就是指定bean的生命周期的各个阶段使用什么方法的一个过程，一般可以实现接口的方式也可以在文件里面指定，建议不要使用实现接口的方式，因为这个我们的程序就和spring的API绑定在一起了 注入bean给集合类型注入值，例如我的domain类里面有一个数组属性empName： 123456789101112131415161718192021package com.ganmy.collection;public class Department &#123; private String name; private String[] empName; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String[] getEmpName() &#123; return empName; &#125; public void setEmpName(String[] empName) &#123; this.empName = empName; &#125; &#125; 配置文件： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;bean id="department" class="com.ganmy.collection.Department"&gt; &lt;property name="name" value="财务部"/&gt; &lt;!-- 给数组注入值 --&gt; &lt;property name="empName"&gt; &lt;list&gt; &lt;value&gt;小米&lt;/value&gt; &lt;value&gt;大米&lt;/value&gt; &lt;value&gt;老米&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类： 1234567891011121314package com.ganmy.collection;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App1 &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("com/ganmy/collection/beans.xml"); Department dt = (Department) ac.getBean("department"); for(String name:dt.getEmpName())&#123; System.out.println(name); &#125; &#125;&#125; 通过集合获取配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;bean id="department" class="com.ganmy.collection.Department"&gt; &lt;property name="name" value="财务部"/&gt; &lt;!-- 给数组注入值 --&gt; &lt;property name="empName"&gt; &lt;list&gt; &lt;value&gt;小米&lt;/value&gt; &lt;value&gt;大米&lt;/value&gt; &lt;value&gt;老米&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 给list注入值 --&gt; &lt;property name="emplist"&gt; &lt;list&gt; &lt;ref bean="emp1"/&gt; &lt;ref bean="emp2"/&gt; &lt;ref bean="emp2"/&gt; &lt;ref bean="emp2"/&gt; &lt;ref bean="emp1"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 给set注入值 --&gt; &lt;property name="empset"&gt; &lt;set&gt; &lt;ref bean="emp1"/&gt; &lt;ref bean="emp2"/&gt; &lt;ref bean="emp2"/&gt; &lt;ref bean="emp2"/&gt; &lt;ref bean="emp1"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 给map注入值 --&gt; &lt;property name="empMaps"&gt; &lt;map&gt; &lt;entry key="1" value-ref="emp1"/&gt; &lt;entry key="2" value-ref="emp2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="emp1" class="com.ganmy.collection.Employee"&gt; &lt;property name="name" value="阿发" /&gt; &lt;property name="id" value="1" /&gt; &lt;/bean&gt; &lt;bean id="emp2" class="com.ganmy.collection.Employee"&gt; &lt;property name="name" value="阿呆" /&gt; &lt;property name="id" value="2" /&gt; &lt;/bean&gt;&lt;/beans&gt; domain类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ganmy.collection;import java.util.List;import java.util.Map;import java.util.Set;public class Department &#123; private String name; private String[] empName; private Employee emp; private List&lt;Employee&gt; emplist; private Set&lt;Employee&gt; empset; private Map&lt;String,Employee&gt; empMaps; public Map&lt;String, Employee&gt; getEmpMaps() &#123; return empMaps; &#125; public void setEmpMaps(Map&lt;String, Employee&gt; empMaps) &#123; this.empMaps = empMaps; &#125; public Set&lt;Employee&gt; getEmpset() &#123; return empset; &#125; public void setEmpset(Set&lt;Employee&gt; empset) &#123; this.empset = empset; &#125; public List&lt;Employee&gt; getEmplist() &#123; return emplist; &#125; public void setEmplist(List&lt;Employee&gt; emplist) &#123; this.emplist = emplist; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String[] getEmpName() &#123; return empName; &#125; public void setEmpName(String[] empName) &#123; this.empName = empName; &#125; public Employee getEmp() &#123; return emp; &#125; public void setEmp(Employee emp) &#123; this.emp = emp; &#125; &#125; 取数据： 12345678910111213141516171819202122232425262728293031323334ApplicationContext ac = new ClassPathXmlApplicationContext("com/ganmy/collection/beans.xml"); Department dt = (Department) ac.getBean("department"); Map&lt;String,Employee&gt; map = dt.getEmpMaps(); System.out.println("**********通过数组取出数据*********"); for(String name:dt.getEmpName())&#123; System.out.println(name); &#125; System.out.println("**********通过list集合取出数据*********"); for(Employee emp:dt.getEmplist())&#123; System.out.println(emp.getName()+"，编号是"+emp.getId()); &#125; System.out.println("**********通过set集合取出数据*********"); for(Employee emp:dt.getEmpset())&#123; System.out.println(emp.getName()+"，编号是"+emp.getId()); &#125; System.out.println("**********通过map集合取出数据的三种方式*********"); //使用迭代器取出数据 System.out.println("**********使用keySet迭代器取出数据**********"); Iterator&lt;String&gt; it = map.keySet().iterator(); while(it.hasNext())&#123; String key = it.next(); System.out.println(map.get(key).getName()); &#125; //通过for-each循环取出数据 System.out.println("**********通过for-each循环取出数据**********"); Set&lt;Entry&lt;String, Employee&gt;&gt; entrys = map.entrySet(); for(Entry&lt;String, Employee&gt; entry:entrys)&#123; System.out.println(entry.getValue().getName()); &#125; //通过keySet取出map数据[for-each循环] System.out.println("**********for-each循环遍历]通过keySet取出map数据**********"); for(String key:map.keySet())&#123; System.out.println(map.get(key).getName()); &#125; 注意：list集合里面可以放相同的对象，但是set集合如果有相同的对象，后面的对象会覆盖前面的对象，和j2se里面一样,然后在map里面如果有相同的key，那么后面的key对应的value会覆盖前面的key对应的对象。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring补充]]></title>
    <url>%2Fspring_add.html</url>
    <content type="text"><![CDATA[引入约束操作myeclipse自带spring相关约束，不需要手动导入，但是eclipse需要手动导入，这里介绍一下手动导入的方法 window-&gt;preferences，搜索cata 点击文件目录按钮 选择spring里面的schema里面的最新的xsd文件，然后确定确定就可以了 然后在applicationContex.xml里面输入&lt;beans&gt;&lt;/beans&gt;元素，切换到Design界面，选中beans，右键点击Edit NameSpace 导入xsi文件 导入xsd文件 复制文件夹路径 导入完成 spring创建对象的三种方法1、通过无参构造方法创建，就是最常见的applicationContext.getbeans(“XX”)创建 2、静态工厂创建： 例如在配置文件里面这样写： 1&lt;bean name=&quot;user2&quot; class=&quot;ganmy.factory.b_create_Userfactory&quot; factory-method=&quot;createUser&quot;&gt;&lt;/bean&gt; 这表示调用ganmy.factory.b_create_Userfactory类里面的静态方法createUser方法创建对象，所以这个方法要返回一个对象，例如： 1234public static User createUser()&#123; System.out.print("静态工厂创建") return new User();&#125; 3、实例工厂创建 和上面唯一不同就是这个createUser不是静态的，例如 1234public User createUser()&#123; System.out.print("实例工厂创建") return new User();&#125; 配置文件： 12&lt;bean name="user3" factory-bean="createFactory" factory-method="createUser"&gt;&lt;/bean&gt;&lt;bean name="createFactory" class="com.ganmy.beanfactory.CreateFactory"&gt;&lt;/bean&gt; 调用： 1234public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); User user = (User) ac.getBean("user3");&#125; 意思是通过createFactory这个bean对应的类的createUser方法创建实例 关于bean的id属性和name属性1、id属性是相当于bean的表示，是唯一的，且不能含有特殊符号。 2、name属性相当于bean的alias，也就是别名，可以有多个，可以和其他bean重名，也可以包含特殊符号， 3、如果没有指定id但是指定了name则默认将name的值赋给id。 关于模块化可以通过import属性导入其他配置文件 12&lt;!-- 导入其他配置文件 --&gt;&lt;import resource="com/ganmy/aop/beans.xml"/&gt; p名称空间注入p名称注入是spring新添加的注入方式，需要改写xsd配置，在applicationContext.xml文件里面添加 1xmlns:p="http://www.springframework.org/schema/p" 这样就可以使用p名称空间注入的方式 123&lt;!-- p名称空间注入 --&gt;&lt;bean name="user1" class="com.ganmy.bean.User" p:name="hhh" p:age="18" p:car-ref="#"&gt;&lt;/bean&gt; 注意当注入引用类型的时候，在配置文件里面引用要用 p-属性-ref的格式，还是走的set方法 spel注入全称是spring Expression Language 翻译是spring表达式语言，类似el表达式，例如： 12345678 &lt;bean name="user" class="com.ganmy.bean.User"&gt; &lt;property name="name" value="张三111"/&gt; &lt;property name="age" value="12"/&gt; &lt;/bean&gt;&lt;bean name="user4" class="com.ganmy.bean.User" &gt; &lt;property name="name" value="#&#123;user.name&#125;"/&gt; &lt;property name="age" value="#&#123;user.age&#125;"/&gt;&lt;/bean&gt; 这样user4的name和age都是引用user的name和age，但是引用类型不能用这种方式引用 将spring容器用servletContext对象监听web.xml 1234567891011&lt;!-- 让spring容器随着项目的启动而创建，项目的关闭而销毁 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 通过context-param指定spring配置文件的位置 --&gt; &lt;context-param&gt; &lt;!-- 指定监听器 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 指定配置文件位置 --&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; strtus的action类 12345//从Application域获得spring容器//获取ServletContext对象ServletContext sc = ServletActionContext.getServletContext();//从sc获取ac对象WebApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc); 注解1、@controller 控制器（web层） 2、@service （service层） 3、@repository （dao层） 4、@component （把普通pojo实例化到spring容器中，相当于配置文件中的） 下面写这个是引入component的扫描组件 1&lt;context:component-scan base-package=”com.mmnc”&gt; 其中base-package为需要扫描的包（含所有子包） 1、@Service用于标注业务层组件2、@Controller用于标注控制层组件(如struts中的action)3、@Repository用于标注数据访问组件，即DAO组件.4、@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“***”)这样来指定，这种bean默认是单例的，如果想改变，可以使用 12345@Service(“beanName”)@Scope(“prototype”)public class User &#123;&#125; 来改变。可以使用以下方式指定初始化方法和销毁方法（方法名任意）： 12345678@PostConstruct //在对象被创建后调用，相当于init-methodpublic void init() &#123; System.out.println(&quot;初始化方法&quot;);&#125; @PostDestory //在对象被销毁前调用，相当于destory-methodpublic void destory() &#123; System.out.println(&quot;销毁方法&quot;);&#125; scope默认类型是singleton，可以通过注解改成prototype 1@Scope("prototype") 属性值的注入使用@Value() 12345678910@Value("张三")private String name;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125; 也可以放到set方法上 123456789private String name;public String getName() &#123; return name;&#125;@Value("张三")public void setName(String name) &#123; this.name = name;&#125; 这两种是有差别的 前者是通过反射的Field赋值，后者是通过set方法赋值 一般用后者，前者破坏了面向对象的封装性，反射机制直接访问了private属性，但是日常使用的时候，还是前者多 可以使用@Autowired 自动装配来注入对象，就是有多个对象的时候不好 也可以使用@Qualifier(“car2”) 告诉spring容器自动装配哪个名称的对象 还可以使用@Resource(name=”car2”)手动注入，指定注入哪个名称的bean对象 推荐使用手动注入]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring的基本使用]]></title>
    <url>%2Fspring_start.html</url>
    <content type="text"><![CDATA[spring是目前java三大框架里面最流行的框架，spring的意思是春天，意味着java程序员的春天到来了，通过spring的IOC思想，我们在再也不需要去new一个对象啦(捂脸)，作为一个容器框架，不管是domian对象还是数据流还是service对象，我们已知的任何java对象几乎都可以注入到spring里面。 案例使用spring2.5.5开发的 1、引入spring开发包，最小配置是spring.jar和日志包(common-logging.jar) 2、创建service对象 1234567891011121314151617181920package com.service;public class UserService &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void sayHello()&#123; System.out.println("hello" +name); &#125;&#125; 2、创建spring核心文件(applicationContext.xml)，该文件一般放在src目录下 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;&lt;!-- 在容器文件中配置bean(service/dao/domain/数据源) --&gt;&lt;!-- bean元素的作用是，当我们的spring框架加载的时候，spring会自动创建一个bean对象，并放入内存 --&gt; &lt;bean id="userService" class="com.service.UserService"&gt; &lt;!-- 这个是UserService里面的属性，这里体现出注入的概念--&gt; &lt;property name="name"&gt; &lt;!-- 这个是UserService的属性的值--&gt; &lt;value&gt;明阳&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注意spring在2.0之前的版本使用的是dtd声明，之后使用schema声明，然后spring里面的bean可以代表任何java对象 3、调用 1234567891011121314import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.service.UserService;public class Test &#123; public static void main(String[] args) &#123; //得到spring的applicationContext对象 ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); UserService us = (UserService) ac.getBean("userService"); us.sayHello(); &#125;&#125; spring处理类与类之间的关系，例如UserService里面还有一个属性对象ByService就这样写 12345678910&lt;bean id="userService" class="com.service.UserService"&gt; &lt;property name="name"&gt; &lt;value&gt;明阳&lt;/value&gt; &lt;/property&gt; &lt;!-- 在userService中引用byService --&gt; &lt;property name="byService" ref="byService" /&gt; &lt;/bean&gt; &lt;bean id="byService" class="com.service.ByService"&gt; &lt;property name="name" value="张三" /&gt; &lt;/bean&gt; 注意这个name很重要，例如name为byService，spring在反射的时候就用这个ByService作为get和set的方法名 当程序执行到 1ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); 的时候会去加载applicationContext.xml文件，然后通过反射机制new出了bean对象，并且放到内存中去，spring实际上是一个容器框架，可以配置各种bean并且可以维护bean与bean之间的关系，当我们需要使用某个bean的时候，我们可以直接getbean(id)即可。 IOCioc全称是inverse of control，翻译成中文就是控制反转，所谓控制反转就是把创建对象和维护对象的关系的权利从程序中转移到spring容器文件applicationContext.xml中，程序本身不再维护 DIDI全称是dependency in_jection，翻译成中文就是依赖注入，实际上DI和IOC是同一个概念，spring的设计者认为DI更能表示SPring的核心 另外ApplicationContext是一个重量级的类，我们要使用单例模式来创建 1234567891011121314151617181920212223package com.util;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;//对这个类使用final修饰防止被其他类继承final public class ApplicationContextUtil &#123; private static ApplicationContext ac= null; //把构造方法私有化 private ApplicationContextUtil()&#123;&#125; //第一次加载这个类的时候才创建，使用静态代码块创建 static&#123; ac = new ClassPathXmlApplicationContext("applicationContext.xml"); &#125; //提供get方法调用 public static ApplicationContext getApplicationContext()&#123; return ac; &#125; &#125; model层范围很大，包括(业务层+dao层+持久层)，在一个项目中不一定三层全部都有，可以根据实际情况选择，hibernate是持久层，主要解决了关系模型和对象模型之间的阻抗，是一个orm框架。 IOP编程 IOP变成就是面向接口编程，是spring里面比较提倡的一种做法，通过IOC和DI还可以解决层与层之间的解耦，下面使用一个例子说明IOP的好处： 创建一个改变字母大小写的接口 12345678package com.ganmy.inter;public interface ChangeLetter &#123; //给这个接口声明一个方法 public String change();&#125; 两个实现ChangeLetter的类 123456789101112131415161718package com.ganmy.inter;public class LowwerLetter implements ChangeLetter &#123; public String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; //把小写字母变为大写 public String change() &#123; return str.toLowerCase(); &#125;&#125; 123456789101112131415161718package com.ganmy.inter;public class UpperLetter implements ChangeLetter &#123; private String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; //把小写字母转成大写 public String change() &#123; return str.toUpperCase(); &#125;&#125; 配置文件beans.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;bean id="changeLetter" class="com.ganmy.inter.LowwerLetter"&gt; &lt;property name="str" value="Hello" /&gt; &lt;/bean&gt;&lt;/beans&gt; 调用： 1234567891011121314package com.ganmy.inter;import org.springframework.context.ApplicationContext;import com.util.ApplicationContextUtil;public class App1 &#123; public static void main(String[] args) &#123; ApplicationContext ac = ApplicationContextUtil.getApplicationContext(); //使用接口来访问bean ChangeLetter changeLetter = (ChangeLetter) ac.getBean("changeLetter"); System.out.println(changeLetter.change()); &#125;&#125; IOP相对OOP有一个好处，由于在调用里面对象的指向始终都是ChangeLetter，我们可以想要这个方法大写只需要改动beans.xml里面changeLetter的class的指向，无需改动代码，这样当代码上了生产环境我们也可以改动业务逻辑了，大大的减少了web层和业务层之间的耦合度。 scope属性在配置文件 当scope的值为singleton的时候，是单例模式，只会调用一次，可以验证 如图所示，构造方法只调用一次并且s1和s2的地址是相同的 而且创建容器的时候就把所有对象创建了 接下来我将scope改为prototype 我们会发现构造方法被调用了两次而且对象的地址不同，说明创建了两个对象，然后我将getbean()去掉，发现没有调用构造方法，所以scope的值为prototype的时候也是类似懒加载的模式 bean的值还有可能是request，session以及global session，这些在web开发的时候才用得着，分别表示生命周期为request、session已经整个spring的周期，global session创建的实例只要spring不关闭就一直存在。 另外当scope的值为prototype的时候，对内存的消耗比较大，要避免使用prototype，尽量使用singleton 通过构造函数注入属性值之前在beans.xml里面配置property是通过set和get方法注入的，在spring里面也可以通过构造函数注入，例如我要注入一个Employee对象，使用构造函数注入： 1234567891011121314151617181920212223242526272829303132package com.ganmy.constructor;public class Employee &#123; private String name; private int age; //无参的构造函数 public Employee()&#123;&#125;; public Employee(String name, int age) &#123; System.out.println("public Employee(String name, int age)这个构造函数被调用"); this.name = name; this.age = age; &#125; public Employee(String name) &#123; System.out.println("public Employee(String name)这个构造函数被调用"); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 配置文件 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;!-- 配置一个雇员对象 --&gt; &lt;bean id="employee" class="com.ganmy.constructor.Employee"&gt; &lt;constructor-arg index="0" type="java.lang.String" value="大明"/&gt; &lt;/bean&gt;&lt;/beans&gt; 获取还是和之前一样获取，另外要注意两点： 1、默认的构造方法要配置 2、spring会自动匹配对应的constructor-arg类型的构造方法，例如上面会调用Employee(String name)的构造方法，如果我按下面所示配置： 1234&lt;bean id="employee" class="com.ganmy.constructor.Employee"&gt; &lt;constructor-arg index="0" type="java.lang.String" value="大明"/&gt; &lt;constructor-arg index="1" type="int" value="23"/&gt; &lt;/bean&gt; 则会调用Employee(String name, int age)的构造方法。 3、还可以添加第三个参数 name=”name”表示指定参数名称 set注入和构造函数注入的对比： 使用set注入，我们可以只注入某个属性，对程序的限制更加宽松，如果使用构造函数注入要根据构造函数的规定来严格参数的选择，假如我只提供一个两个参数的构造函数，那么必须根据这两个参数的顺序类型来注入参数，不然就会报错，一般还是set用得更多。 自动装配例如： 1234567891011121314151617181920package com.ganmy.autowire;public class Master &#123; private String name; private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; &#125; 1234567891011121314151617181920package com.ganmy.autowire;public class Dog &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;!-- 配置一个master对象 --&gt; &lt;bean id="master" class="com.ganmy.autowire.Master" autowire="byName"&gt; &lt;property name="name" value="明阳"/&gt; &lt;/bean&gt; &lt;!-- 配置一个dog对象 --&gt; &lt;bean id="dog" class="com.ganmy.autowire.Dog"&gt; &lt;property name="name" value="大黄"/&gt; &lt;property name="age" value="5"/&gt; &lt;/bean&gt;&lt;/beans&gt; 解释： 1、当程序加载到ClassPathXmlApplicationContext()的时候，去加载配置文件，在内存里面创建对象，创建master对象的时候，由于name属性我们已经注入，但是dog属性并没有注入，这个时候dog指向null，由于我们设置自动装箱为byName，会根据dog属性去配置文件里面去找id为dog的bean注入到我们的master里面，由于是根据id去找的，不会出现重复的情况。 2、autowire的值还可以设置为byType，byType就是根据类型去找，如果在beans.xml里面匹配到多个对象则会抛出异常，另外byType是去创建对象还是通过对象的默认构造方法创建的，如果没有默认构造方法就会报错 3、autowire的值为constructor，是根据构造方法去找的，程序在加载到autowire=”constructor”的时候会创建master对象，然后加载到dog属性的时候发现dog属性没有注入，于是试图通过有dog对象的构造函数来创建dog 4、autowire的值为autodetect，表示自动匹配创建方法，优先通过bytype的方式创建，如果不符合bytype再通过constructor的方式创建 5、autowire的值为default，如果不指定autowire属性那么autowire的值就默认是default，当autowire=”default”的时候，具体的类型是根据上面的配置指定的，例如： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd" default-autowire="byName"&gt; &lt;!-- 配置一个master对象 --&gt; &lt;bean id="master" class="com.ganmy.autowire.Master" autowire="default"&gt; &lt;property name="name" value="明阳"/&gt; &lt;/bean&gt; &lt;!-- 配置一个dog对象 --&gt; &lt;bean id="dog" class="com.ganmy.autowire.Dog"&gt; &lt;property name="name" value="大黄"/&gt; &lt;property name="age" value="5"/&gt; &lt;/bean&gt;&lt;/beans&gt; 由于default-autowire为byName，那么autowire也为byName，然后default-autowire的默认值为no，所以当autowire和default-autowire都没写的时候，default-autowire的值为no，autowire的值为default，然后autowire根据default-autowire的值传递变为no 一般自动装配很少使用，大部分情况用set就行了 分派器引入文件，然后可以读取文件的信息，例如我们要配置JDBC，可以将jdbc的信息写到一个配置文件里面，然后在代码里面去读取 创建两个.properties文件 db.properties 1234name=rootdirver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/userspwd=root db1.properties 1234name1=root1dirver1=com.mysql.jdbc.Driver1url1=jdbc:mysql://localhost:3306/users1pwd1=root1 DBUtile.java 1234567891011121314151617181920212223242526272829303132333435package com.ganmy.dispatch;public class DBUtil &#123; private String dirver; private String url; private String name; private String pwd; public String getDirver() &#123; return dirver; &#125; public void setDirver(String dirver) &#123; this.dirver = dirver; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; &#125; beans.xml文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;!-- 引入我们的db.properties，使用逗号隔开 --&gt; &lt;context:property-placeholder location="com/ganmy/dispatch/db.properties,com/ganmy/dispatch/db1.properties"/&gt; &lt;!-- 配置DBUtil对象,$表示占位符，使用占位符可以调用变量，如果不写就表示硬编码，也就是写死的字符串了--&gt; &lt;bean id="dbutil" class="com.ganmy.dispatch.DBUtil"&gt; &lt;property name="name" value="$&#123;name&#125;"/&gt; &lt;property name="dirver" value="$&#123;dirver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="pwd" value="$&#123;pwd&#125;"/&gt; &lt;/bean&gt; &lt;!-- 配置 DBUtil1对象--&gt; &lt;bean id="dbutil1" class="com.ganmy.dispatch.DBUtil"&gt; &lt;property name="name" value="$&#123;name1&#125;"/&gt; &lt;property name="dirver" value="$&#123;dirver1&#125;"/&gt; &lt;property name="url" value="$&#123;url1&#125;"/&gt; &lt;property name="pwd" value="$&#123;pwd1&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 我们调用的时候可以选择DBUtil1对象或者DBUtil1对象有选择的调用配置文件的信息]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate里的HQL使用详解]]></title>
    <url>%2Fhibernate_hql.html</url>
    <content type="text"><![CDATA[HQL介绍HQL是Hibernate Query Language的简写，翻译成中文就是hibernate查询语言，是面向对象的查询语句，功能强大，由于实际需求的复杂性，对数据库的操作有很多条件，用原始的get()和load()远远满足不了需求，这个时候hibernate推出了功能强大的HQl语句，hql语句和sql语句不同，hql严格区分大小写，并且支持多态。 hibernate设计者建议数据库所有表都要有主键，而且最好是不要带业务逻辑的主键，原因： 1、很多情况下业务需求有可能改动，那么就面临要修改主键，对这条数据来说修改主键就面临数据不稳定的状态。 2、带有业务逻辑的数据有可能会重复，比如早期的身份证号，由于很多原因，出现了重复的现象。 例如我对查询student表里面所有属性 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; //举例说明hql语句使用 Session session = null; Transaction ts = null; try&#123; session = HibernateUtil.getCurrentSession(); ts = session.beginTransaction(); //检索所有学生信息 List&lt;Student&gt; list = session.createQuery("from Student").list(); //取出数据 for(Student s:list)&#123; System.out.println(s.getSname()); System.out.println(s.getSaddress()); &#125; System.out.println("***********************"); //使用Iterator迭代器取出数据 Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student s = iterator.next(); System.out.println(s.getSname()); System.out.println(s.getSage()); &#125; ts.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(ts != null)&#123; ts.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session != null &amp;&amp; session.isOpen())&#123; session.close(); &#125; &#125; &#125; 这里最主要的语句就是List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).list();这一句，由于在hibernate里面一张表对应一个类，我们的student表对应的类就是Student，hql语句面向对象的，是去查询这个类的属性而不是去查表的属性，直接’from student’就表示查询Student的所有属性，返回一个装满Student对象的集合，然后我们只需要对集合做操作就可以了，可以使用for循环增强也可以使用Iterator迭代器取出数据。两种方式上面都列举出来了。 在jdbc里面一般不要使用select * from 表名，但是这个规定在hibernate里面可以不遵循这个规则，如果遵循这个规则Hibernate的优势体现不出来，hibernate建议我们把整个对象的所有属性都查出来。 如果要查询部分信息，那么只需要将hql语句改动就可以了，例如我只想查询名字和所在系： 改成 1List list = session.createQuery("select sname, sdept from Student").list(); 但是由于我们只是查询一部分数据，不足以构成一个Student，所以不能用Student类的方法来取数据，使用以下方法取出数据 1234for(int i=0;i&lt;list.size();i++)&#123; Object[] objs = (Object[]) list.get(i); System.out.println("名字是：" + objs[0].toString() + ",所在系是：" + objs[1].toString());&#125; 这是因为数据不足以构成student对象，于是使用数组代替，这个list里面是像数据库一样两列多行数据，我们取出第一行数据，这个数据会放到一个数组里面，由于不知道数据的类型，就使用object对象指带，防止报错。当然，这种情况我们还得自己做二次封装，比较麻烦。不能发挥hibernate关联查询的特点。所以还是建议使用hibernate的所有查询语句，其实浪费的性能不多，因为实际上我们去查询都会带上各自条件，并且会带上分页，其实每一次查询出来的数据量一般不会特别多，我们甚至可以查出关联外键表的数据 1234567891011List&lt;Student&gt; list = session.createQuery("from Student").list();for(Student s:list)&#123; if(s.getStudcourses().size()==0)&#123; System.out.println(s.getSname()+"没有选课"); &#125;else&#123; Set&lt;Studcourse&gt; set= s.getStudcourses(); for(Studcourse sc: set)&#123; System.out.println(s.getSname()+"选了"+sc.getCourse().getCname()); &#125; &#125; &#125; hibernate真的是完全的面向对象编程 uniqueResult查询这是hibernate推出的一种查询方法，业务场景是用于查询数据只有一条的情况，因为假如我们使用get()或者load()查询，假如数据量有几百万在查询到的情况下还会接着往下查，uniqueResult查到了不会往下查，例如我们要根据某个id查询 1Student s = (Student) session.createQuery("from Student where sid = '20050003'").uniqueResult(); 如果查到了就返回一个对象，如果是查询全部属性就返回一个Student对象，如果是部分属性就返回一个object[]数组，没有查到会返回null，如果查询结果有多条会抛出异常，用户登录的场景建议使用这种查询 其他用法过滤重复数据使用distinct关键字，例如显示所有学生的性别和年龄 12345List list = session.createQuery("select distinct ssex, sage from Student").list();for(int i =0;i&lt;list.size();i++)&#123; Object[] o = (Object[]) list.get(i); System.out.println("性别是："+o[0]+",年龄是："+o[1]);&#125; 根据区间查询使用bewtween…and.. ，例如我想查询年龄在20岁和22岁之间所有学生的性别 12345List list = session.createQuery("select ssex, sage from Student where sage between 20 and 22").list();for(int i =0;i&lt;list.size();i++)&#123; Object[] o = (Object[]) list.get(i); System.out.println("性别是："+o[0]+",年龄是："+o[1]);&#125; 使用int和 not in来查询，例如我想查询所有年龄为20岁或者22岁的学生 1234List&lt;Student&gt; list = (List&lt;Student&gt;) session.createQuery("from Student where sage in (22,20)").list();for(Student s:list)&#123; System.out.println(s.getSname()+","+s.getSage());&#125; 分组层查询使用group by来查询，例如我想查询各个系的学生的年龄 1234List list = (List&lt;Student&gt;) session.createQuery("select sage from Student group by sdept").list();for(int i =0;i&lt;list.size();i++)&#123; System.out.println("年龄是："+list.get(i));&#125; 这里由于我查询的只有一个属性，不会返回object[]数组了，可以直接从list里面取出来 如果是查询各个系的平均年龄 1234List&lt;Object[]&gt; list = session.createQuery("select avg(sage),sdept from Student group by sdept").list();for(Object[] o:list)&#123; System.out.println("平均年龄是："+o[0]+"所在系是："+o[1]);&#125; 对分组后的数据再次查询使用having来查询，例如我想显示所有人数大于3的系 1234List&lt;Object[]&gt; list = session.createQuery("select sdept, count(*) from Student group by sdept having count(*)&gt;3").list();for(Object[] o:list)&#123; System.out.println(o[0]+"的人数是"+o[1]);&#125; 注意在hibernate里面having后面不能跟别名，要跟聚合函数，看了下sql语句，由于hibernate会把count(*)取一个自动的别名，我们取的别名没有生效，这种情况直接用别名去判断就报错找不到这个字段 查询女生人数少于200的系 1234List&lt;Object[]&gt; list = session.createQuery("select sdept, count(*) from Student where ssex='F' group by sdept having count(*)&lt;200").list();for(Object[] o:list)&#123; System.out.println(o[0]+"的女生人数是"+o[1]);&#125; 查询学生总分 1234List&lt;Long&gt; list = session.createQuery("select sum(grade) from Studcourse").list();for(Long o:list)&#123; System.out.println(o);&#125; 查询选修11号课程的最高分和最低分 1234List&lt;Object[]&gt; list = session.createQuery("select 11,max(grade),min(grade) from Studcourse where course.cid = 11").list();for(Object[] o:list)&#123; System.out.println(o[0]+"最高分是"+o[1]+"最低分是"+o[2]);&#125; 显示各科不及格的学生名字，科目和分数 1234List&lt;Object[]&gt; list = session.createQuery("select student.sname,course.cname,grade from Studcourse where grade &lt; 60").list();for(Object[] o:list)&#123; System.out.println("学生姓名是："+o[0]+"课程名字是："+o[1]+"分数是："+o[2]);&#125; 这里非常巧妙的用到了hibernate的面向对象思想，通过对象的属性获取，如果单纯使用数据库还是不太好处理的 这里是生成的sql语句，感觉写的挺好的 123456789101112select student1_.sname as col_0_0_, course2_.cname as col_1_0_, studcourse0_.grade as col_2_0_ from users.studcourse studcourse0_, users.student student1_, users.course course2_ where studcourse0_.sid=student1_.sid and studcourse0_.cid=course2_.cid and studcourse0_.grade&lt;60 统计各个科目不及格的学生的数量 1234List&lt;Object[]&gt; list = session.createQuery("select count(*),course.cname from Studcourse where grade &lt; 60 group by course.cname").list();for(Object[] o:list)&#123; System.out.println(o[1]+"有"+o[0]+"个学生不及格");&#125; 分页使用关键函数setFirstResult(index)和setMaxResults(index) 例如：按照学生年龄从小到大取出第一个到第三个学生 1234List&lt;Student&gt; list = session.createQuery("from Student order by sage asc").setFirstResult(0).setMaxResults(3).list();for(Student s:list)&#123; System.out.println(s.getSname()+"年龄是"+s.getSage());&#125; 注意setFirstResult的参数表示数据的下标，setMaxResults的参数表示后面几位，和limit的用法一样 封装成函数 12345678910111213141516171819202122232425262728293031323334353637//分页函数 private static void showResultByPage(int pageSize)&#123; Session session = null; Transaction ts = null; //总条数 int rowCount = 1; //当前页数 int pagenow = 1; //总页数 int pagecount = 1; try&#123; session = HibernateUtil.getCurrentSession(); ts = session.beginTransaction(); rowCount = Integer.parseInt(session.createQuery("select count(*) from Student").uniqueResult().toString()); pagecount = (rowCount-1)/pageSize+1; for(int i =0;i&lt;pagecount;i++)&#123; List&lt;Student&gt; list = session.createQuery("from Student order by sage asc").setFirstResult(i*pageSize).setMaxResults(pageSize).list(); System.out.println("*********************这是第"+(i+1)+"页"); for(Student s:list)&#123; System.out.println(s.getSname()+"年龄是"+s.getSage()); &#125; &#125; ts.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(ts != null)&#123; ts.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session != null &amp;&amp; session.isOpen())&#123; session.close(); &#125; &#125; &#125; 调用 1234public static void main(String[] args) &#123; showResultByPage(2); &#125; 这个分页方法还是非常方便的，不管什么数据库都可以使用，hibenate会转化成相应的sql语句 hibernate参数绑定使用关键函数，setParameter() ,使用参数绑定的好处： 1、可读性好 2、性能提高 3、防止sql注入漏洞 关于sql注入漏洞，举例说明： 我的数据库表： 使用sql语句查询 1SELECT * from student where sid = 20050005 and sdept=&apos;生物系&apos; 可以查到数据 改一下： 1SELECT * from student where sid = 20050005 and sdept=&apos;生物系111&apos; 查不到数据 再改一下 1SELECT * from student where sid = 20050005 and sdept=&apos;生物系111&apos; or 1=&apos;1&apos;; 所有的数据都出来了 实际上这是因为where执行的语句可以返回一个boolean，当这个boolean的值为true的时候，会查出所有数据，当这个boolean的值为false的时候，就什么都查不到，例如我们直接使用true来查，看结果 所谓的sql注入漏洞其实就是通过or语句来返回一个true，达到获取用户所有数据的目的 参数绑定有两种形式： 1、使用:字段名 1List&lt;Student&gt; list = session.createQuery("from Student where sdept=:a1 and sage&gt;:sage").setString("a1", "计算机系").setString("sage", "2").list(); 注意 “:” 后面的字符串可以随便取名，但是一般和字段名保持一致，后面的setString不能用位置做第一个参数 2、使用?占位符 1List&lt;Student&gt; list = session.createQuery("from Student where sdept=? and sage&gt;?").setString(0, "计算机系").setString(1, "2").list(); 这样使用?占位符后面的setString才能用位置做第一个参数，然后参数是从0开始编号的 另外query是可以分开写的，不是一定要连起来写 1234Query query = session.createQuery("from Student where sdept=? and sage&gt;?");query.setString(0, "计算机系");query.setString(1, "2");List&lt;Student&gt; list = query.list(); 由此我们可以引申，使用for循环注入，将方法封装起来 1234567891011121314151617181920212223//提供一个统一的查询方法，hql形式，使用?的方式,由于openSession在查询的时候不需要使用事务提交，就不用openSession public static List excuteQuery(String hql,String[]parameters)&#123; List list = null; Session s = null; try&#123; s = OpenSession(); Query query = s.createQuery(hql); if(parameters !=null &amp;&amp; parameters.length&gt;0)&#123; for(int i=0;i&lt;parameters.length;i++)&#123; query.setString(i, parameters[i]); &#125; &#125; list = query.list(); &#125;catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(s!=null&amp;&amp;s.isOpen())&#123; s.close(); &#125; &#125; return list; &#125; 关于静态的使用，代码块本身是可以静态的，但是session要保证每次都是一个新的，不是当前的那个，防止阻塞的问题 关于调用 12345678public static void main(String[] args) &#123; String hql = "from Student where sdept=? and sage&gt;?"; String[] parameters = &#123;"计算机系","2"&#125;; List&lt;Student&gt; list = HibernateUtil.excuteQuery(hql, parameters); for(Student s:list)&#123; System.out.println("学生姓名是" + s.getSname() + ",学生年龄是"+s.getSage()); &#125;&#125; 将以上代码功能完善，添加分页功能 12345678910111213141516171819202122232425//提供一个统一的分页查询 public static List excuteQueryByPage(String hql,String[]parameters,int pagenow,int pagesize)&#123; List list = null; Session s = null; try&#123; s = OpenSession(); Query query = s.createQuery(hql); if(parameters !=null &amp;&amp; parameters.length&gt;0)&#123; for(int i=0;i&lt;parameters.length;i++)&#123; query.setString(i, parameters[i]); &#125; &#125; query.setFirstResult((pagenow-1)*pagesize).setMaxResults(pagesize); list = query.list(); &#125;catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(s!=null&amp;&amp;s.isOpen())&#123; s.close(); &#125; &#125; return list; &#125; 这个时候main方法调用 12345678910public static void main(String[] args) &#123; String hql = "from Student where sdept=? and sage &gt; ?"; String[] parameters = &#123;"计算机系","2"&#125;; int pagenow = 1; int pagesize = 5; List&lt;Student&gt; list = HibernateUtil.excuteQueryByPage(hql, parameters, pagenow, pagesize); for(Student s:list)&#123; System.out.println("学生姓名是" + s.getSname() + ",学生年龄是"+s.getSage()); &#125; &#125; 然后是统一的添加方法 1234567891011121314151617181920public static void excuteAdd(Object obj)&#123; Session session = null; Transaction tx = null; try&#123; session = OpenSession(); tx = session.beginTransaction(); session.save(obj); tx.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(tx!=null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session!=null&amp;&amp;session.isOpen())&#123; session.close(); &#125; &#125; &#125; 统一的修改和删除方法 1234567891011121314151617181920212223242526public static void excuteUpdate(String hql,String[] parameters)&#123; Session s = null; Transaction tx = null; try&#123; s = OpenSession(); tx = s.beginTransaction(); Query query = s.createQuery(hql); if(parameters !=null &amp;&amp; parameters.length&gt;0)&#123; for(int i=0;i&lt;parameters.length;i++)&#123; query.setString(i, parameters[i]); &#125; &#125; query.executeUpdate(); tx.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(tx!=null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(s!=null&amp;&amp;s.isOpen())&#123; s.close(); &#125; &#125; &#125; 使用子查询例如查询所有选课为21号的学生的信息 有两个方法，一、获取Studcourse对象，根据Studcourse获取Student对象 123456String hql = "from Studcourse where course.cid=21"; String[] parameters = null; List&lt;Studcourse&gt; list = HibernateUtil.excuteQuery(hql, parameters); for(Studcourse o:list)&#123; System.out.println(o.getGrade()+o.getStudent().getSname()); &#125; 这里有一个懒加载的问题，会报错 1Exception in thread "main" org.hibernate.LazyInitializationException: could not initialize proxy - no Session 这是由于我们获取的Student对象是一个代理对象(proxy)，由于session已经关闭，到数据库查询会报错 对Student.hbm.xml设置禁用懒加载，添加属性laze=”false”就可以了，但是这种方式会多次连接数据库，for循环有几次就会去数据库查几次，效率很低下 方法二、通过面向对象取出来 123456String hql = "select student.sname,student.sid from Studcourse where course.cid=21"; String[] parameters = null; List&lt;Object[]&gt; list = HibernateUtil.excuteQuery(hql, parameters); for(Object[] o:list)&#123; System.out.println(o[0]+","+o[1]); &#125; 这种方法的缺点是hql语句过长 critiria使用critiria是一种更加面向对象的查询，例如查询年龄大于10岁的学生 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; Session session = null; Transaction tx = null; try&#123; session = HibernateUtil.OpenSession(); tx = session.beginTransaction(); Criteria cri = session.createCriteria(Student.class); //添加条件,这里Restrictions.gt()里面的gt表示大于，ge表示大于等于，lt小于，le小于等于 cri.add(Restrictions.gt("sage", new Integer(10))); List&lt;Student&gt; list = cri.list(); for(Student s:list)&#123; System.out.println(s.getSname()); &#125; tx.commit(); &#125;catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session!=null&amp;&amp;session.isOpen())&#123; session.close(); &#125; &#125; &#125; 使用模糊查询 例如：查出所有成姓学生 123456String hql = "from Student where sname like ?"; String[] parameters = &#123;"成%"&#125;; List&lt;Student&gt; list= HibernateUtil.excuteQuery(hql, parameters); for(Student s:list)&#123; System.out.println(s.getSname()); &#125; 创建数据库如果我们要创建出对应的数据库，需要配置hibernate.cfg.xml，添加配置信息 1&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt; 这个标签里面有四种类型的值： 1、create，当我们的应用程序加载hibernate.cfg.xml的时候(new configuration().config())就会根据映射文件创建出数据库，每次都会创建，如果原先有表会先删掉再创建 在*.hbm.xml里面的class标签设置生成表的数据库名和表名，然后在hibernate.cfg.xml文件里面添加 1&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt; 主要是这种创建方式会删掉原来表中的数据 2、update，如果数据库中没有该表，则创建，如果有该表，则看有没有变化，如果有变化，则更新，反正不会删掉表里面的数据 例如我将映射的表字段sdept改为sdept1，字段最大长度从30改为20，那么在表里面就会生成一个新的字段sdept1，长度为20，原先的sdept字段和里面的数据还是保留 3、create-drop，在显示关闭sessionFactory的时候，会drop数据库的schema，我们调用sessionFactory创建session用完sessionFactory也会关闭，但是不是显示关闭，必须要我们调用sessionFactory.close()方法才行，尽量不要使用create-drop 4、validate，每次添加数据的时候会验证数据库的表结构和hbm的结构是否一致，用的很少 在开发测试的过程中，我们配那个都可以，但是如果上了生产，这个选项最好就删掉，要配置也最好配置update，或者配置一次让数据库表生成，然后还是要删掉 关于domain对象注意： 1、一定要配置默认的构造方法，用于hibernate反射该对象 2、要配置一个没有业务意义的主键 3、给每个属性提供一个get和set方法，原则上一个属性对应数据库表里面的一个字段，或者对应一个对象，如果domian里面有一个字段，我们没有配置到数据库是没有什么关系的，最多只是这个字段不会生成，但是如果我们配置的字段在domain里面没有，就会报错的，因为这个配置会使用domain的反射机制 4、属性一般是private的访问权限 关于可选项在*.hbm.xml文件里面，table属性可以不写，如果不写就默认使用配置的对象第一个字母小写生成 type也可以不配置，如果没有写，就会根据domain对象对应的属性 hibernate对象三种状态在hibernate里面将对象分为三种状态，分别是瞬时(transient)、持久(persistent)、脱管(detached)状态 当一个对象刚被创建还没有处于session的管理之下且在数据库中没有记录的时候，是处于瞬时态的(表示状态不稳定，随时都有可能消失)，然后我们调用session.save()保存这个对象的时候，它就变成了持久态了，然后当session关闭后，这个对象就脱离了session的管理，状态就变成了脱管态(也叫游离态) 当处于瞬时态的时候改变数据，是不会反映的数据库中，当处于持久态的时候，只要使用set()就会反映的数据库中，脱管状态如果要修改是不会反映的数据库中，例如以下这个例子： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; Course course = new Course(61, "php"); //这个时候course既没有处于session管理，也没有在数据库中有数据，是处于瞬时态的，修改不会反映到数据库中 course.setCcredit(5); Session session = null; Transaction tx = null; try&#123; session = HibernateUtil.getCurrentSession(); tx = session.beginTransaction(); //使用了save这个对象的这一瞬间，这个对象就处于持久态 session.save(course); //由于course是处于持久态，我们改变course的cname会反映到数据库中，hibernate产生一条update语句 //hibernate会优化代码。我们的两个改动在hibernate里面只生成一条update语句 course.setCname("php1"); course.setCcredit(6); //如果在这里调用session.delete(course),首先会去数据库删掉数据，那么在session关闭后就又变为瞬时态 //并且处于持久态后只会生成一条delete语句，不会产生upodate语句啦 tx.commit(); &#125;catch (Exception e) &#123; if(tx != null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session!=null&amp;&amp;session.isOpen())&#123; //session关闭这一瞬间，course就处于脱管态 session.close(); //由于course处于脱管态，我们设置php2这个动作不会反映到数据库中 course.setCname("php2"); &#125; &#125; &#125; 完整图解，这里说明一下，使用session的get()、load()、find()、iterate()、etc都会进入持久态，并且不管是openSession还是getCurrentSession()，在commit()后都不是持久态了 hibernate映射关系1、one-to-one，例如身份证和人之间的关系 2、one-to-many，例如部门和员工，一个部门可以有多个员工 3、many-to-one，例如员工和部门，多个员工对应一个部门 4、many-to-many，例如学生和老师，一般在编程中要尽量避免这种关系，如果出现了many-to-many，一般转换成两个one-to-many或者many-to-one，这个程序就好控制，同时不会有冗余，例如我们上面的表已经分解了这种关系，hql语句在多表查询有很多优势 在hibernate里面，外键会映射成一个对象]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[strut1使用]]></title>
    <url>%2Fstrut_start.html</url>
    <content type="text"><![CDATA[要使用strut1，我们得先导入jar包，我使用的版本是1.3.10，jar包下载，密码是：65k9，里面有4个文件夹，jar在lib文件夹里面，然后将jar包导入项目，我们得先将源码和代码关联起来 这样就可以了，我们点击class文件就可以直接打开啦 创建form里面的java文件，这个文件要继承ActionForm这个类才行， 一般按照规范属性的名称和input的name的值保持一样，但是不是必须，主要保证get和set方法属性名，另外方法get或者set后面的第一个字母要大写 代码： 123456789101112131415161718192021package com.ganmy.forms;import org.apache.struts.action.ActionForm;public class UserForm extends ActionForm &#123; //定义属性 private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 然后是action，这个action要继承Action类才行，要重写execute方法，注意是形参为httpServlet的才行，否则会跳不过去 12345678910111213141516171819202122232425262728293031package com.ganmy.actions;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.struts.action.Action;import org.apache.struts.action.ActionForm;import org.apache.struts.action.ActionForward;import org.apache.struts.action.ActionMapping;import com.ganmy.forms.UserForm;public class loginAction extends Action &#123; //重写execute方法，注意是形参为httpServlet的才行，execute会被自动调用，类似doget和dopost方法 @Override public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //把form转成对应的userform类 UserForm userform = (UserForm)form; if("123".equals(userform.getPassword()))&#123; request.setAttribute("username", userform.getUsername()); //findForward是请求转发,要传的参数可以放到request里面传 return mapping.findForward("ok"); &#125;else&#123; return mapping.findForward("error"); &#125; &#125;&#125; 配置struts-config.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE struts-config PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 1.3//EN" "http://struts.apache.org/dtds/struts-config_1_3.dtd"&gt;&lt;struts-config&gt; &lt;!-- 配置表单 --&gt; &lt;form-beans&gt; &lt;!-- name是表单的名字，取名是随意的，但是建议取表单类名的小写--&gt; &lt;!-- type指定表单类的全路径 --&gt; &lt;form-bean name="userForm" type="com.ganmy.forms.UserForm"&gt;&lt;/form-bean&gt; &lt;/form-beans&gt; &lt;!-- 配置action --&gt; &lt;action-mappings&gt; &lt;!-- 配置具体的action path表示将来方法action的uri--&gt; &lt;!-- name用于关联某个表单--&gt; &lt;!-- path用于指定该action路径的全路径 --&gt; &lt;action path="/login" name="userForm" type="com.ganmy.actions.loginAction"&gt; &lt;!-- name表示结果名称，path表示转发到那个页面去 --&gt; &lt;forward name="ok" path="/WEB-INF/welcome.jsp" /&gt; &lt;forward name="error" path="/WEB-INF/error.jsp" /&gt; &lt;/action&gt; &lt;/action-mappings&gt;&lt;/struts-config&gt; 配置web.xml文件 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-class&gt; &lt;!-- 配置struts-config --&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; jsp页面 123456789101112131415161718192021&lt;%@ page language="java" import="java.util.*" pageEncoding="ISO-8859-1"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="/strutsLogin/login.do" method="post"&gt; u:&lt;input type="text" name="username"&gt;&lt;/br&gt; p:&lt;input type="password" name="password"&gt;&lt;/br&gt; &lt;input type="submit" value="login"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 流程原理请求-&gt;web.xml-&gt;转发到strut-config.xml-&gt;读取uri，找到匹配的action-&gt;根据action找到对应的表单(actionform)-&gt;将表单实例化并且将客户输入的数据填充进去-&gt;到action里面取出数据进行逻辑判断返回结果-&gt;strut-config.xml根据返回的结果跳转页面 然后开始测试，出现了一个问题No action config found for the specified url 原因是jsp页面的action写错了，没有带/，改成 1&lt;form action="&lt;%=request.getContextPath() %&gt;/login.do" method="post"&gt; 另外struts-config.xml文件里面也有问题path的值少了”/“，反正报那个错不是jsp的action写错了就是struts-config.xml配置错误 中文乱码由于strut在数据填充在formaction前面，必须要用过滤器来处理编码方式 web.xml里面的代码： 12345678 &lt;filter&gt; &lt;filter-name&gt;Myfilter1&lt;/filter-name&gt; &lt;filter-class&gt;com.ganm.filter.Myfilter1&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;Myfilter1&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; filter那个servlet的代码，需要实现javax.servlet.Filter这个接口 123456789101112131415161718192021import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServlet;public class Myfilter1 extends HttpServlet implements Filter &#123; public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException &#123; arg0.setCharacterEncoding("utf-8");//设置接收编码 System.out.println("进来了过滤器"); arg2.doFilter(arg0, arg1);//必须要有，如果没有会停在这里 &#125;&#125; 其实过滤器也是一个servlet，只不过实现了一个filter接口 Struts-config.xml配置可以在action标签里面添加参数scope=”request”表示将这个action所对应的form表单实例化放到request里面，值可以取为session、request等等，如果不写scope属性默认scope=”session” 1234&lt;action path="/login" name="userForm" scope="request" type="com.ganmy.actions.loginAction"&gt; &lt;forward name="ok" path="/WEB-INF/welcome.jsp" /&gt; &lt;forward name="error" path="/WEB-INF/error.jsp" /&gt;&lt;/action&gt; 每个action都是单态的，包括总控制器ActionServlet，这估计就是struts的缺点，单态存在一些问题： 1、存在线程安全问题 2、并发量过大的时候会影响性能 struts-config的路径不一样要放在WEB_INF下面，可以自己随意放置 3、在一个项目中可以有多个struts配置文件，使用逗号隔开就可以了，例如： 1&lt;param-value&gt;/WEB-INF/config/struts-config.xml, /WEB-INF/config/struts-config_2.xml&lt;/param-value&gt; 使用myeclipse开发struts右键web项目，选择myeclipse，选择add struts Capalities 点击finish会引入struts开发包并且生成struts-config.xml文件和web.xml文件并完成一些配置，后面的都一样 分派action分派action可以将一类请求写到一个action中去处理，可以减少action的数量，有利于程序的维护和拓展 ，例如下面是一个登录和注销的例子： login.jsp 12345&lt;form action="/strutsLogin/loginAndLogout.do?flag=userLogin" method="post"&gt; u:&lt;input type="text" name="username"&gt;&lt;/br&gt; p:&lt;input type="password" name="password"&gt;&lt;/br&gt; &lt;input type="submit" value="login"&gt;&lt;/form&gt; struts-config.xml 1234567891011&lt;action-mappings&gt; &lt;!-- 配置具体的action path表示将来方法action的uri--&gt; &lt;!-- name用于关联某个表单--&gt; &lt;!-- path用于指定该action路径的全路径 --&gt; &lt;!-- scope="request"表示action所对应的表单的作用域是request，parameter表示请求的参数的方法--&gt; &lt;action path="/loginAndLogout" name="userForm" type="com.ganmy.actions.LoginAndLogout" parameter="flag"&gt; &lt;forward name="ok" path="/WEB-INF/welcome.jsp" /&gt; &lt;forward name="error" path="/WEB-INF/error.jsp" /&gt; &lt;/action&gt;&lt;/action-mappings&gt; loginAndLogout.java 1234567891011121314151617181920//该函数用户响应登录请求 public ActionForward userLogin(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)&#123; //把form转成对应的userform类 UserForm userform = (UserForm)form; UserService us = new UserService(); Users users = new Users(); users.setUser_name(userform.getUsername()); users.setUser_pwd(userform.getPassword()); if(us.checkUser(users))&#123; return mapping.findForward("ok"); &#125;else&#123; return mapping.findForward("error"); &#125; &#125; //该函数用于响应注销请求 public ActionForward userLogout(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response)&#123; return mapping.findForward("error"); &#125; welcom.jsp 1&lt;a href="/strutsLogin/loginAndLogout.do?flag=userLogout"&gt;退出系统&lt;/a&gt; 全局跳转1234567891011&lt;!-- 配置全局跳转 --&gt; &lt;global-forwards&gt; &lt;forward name="goerr" path="/WEB-INF/err.jsp" /&gt; &lt;/global-forwards&gt; &lt;!-- 配置action --&gt; &lt;action-mappings&gt; &lt;action path="/loginAndLogout" name="userForm" type="com.ganmy.actions.LoginAndLogout" parameter="flag"&gt; &lt;forward name="ok" path="/WEB-INF/welcome.jsp" /&gt; &lt;forward name="error" path="/WEB-INF/error.jsp" /&gt; &lt;/action&gt; &lt;/action-mappings&gt; 所谓全局跳转是指所有action都可以使用这个跳转，所谓局部跳转是只有本action可以使用的跳转，相当于全局变量和局部变量的区别]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>strut1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate框架配置详解]]></title>
    <url>%2FHibernate_sum.html</url>
    <content type="text"><![CDATA[hibernate主要封装java里面jdbc这部分，是jdbc代码的轻量级的对象封装，使用hibernate有很多好处： 1、降低了代码的耦合性，程序员只需要专注业务代码即可 2、换了数据库只需要改动配置文件即可 3、大大提高程序员的开发效率 4、支持分布式架构 hibernate核心思想是ORM(object relation mapping)，官方推荐先写domain层，再写配置文件，最后生成数据库，但是实际上都是先设计好数据库，然后写配置文件，最后再写domain层，这里也是按照实际顺序配的 数据库代码(使用的是mysql数据库，以employee为例): 1234567CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL, `email` varchar(64) NOT NULL, `hiredate` date NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 我们在这张表里面设计了4列，分别是主键id（int类型），name（varchar类型），email（varchar类型），hiredate（date类型），那么我们的domain类的结构也要设计成一样 1234567891011121314151617181920212223242526272829303132333435package com.ganmy.doman;//这个pojo对象应当按照规范序列号，目的是可以唯一标识该对象,同时可以在网络和文件上传输public class Employee implements java.io.Serializable&#123; //添加序列版本号 private static final long serialVersionUID = 1L; private Integer id; private String name; private String email; private java.util.Date hiredate; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public java.util.Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(java.util.Date hiredate) &#123; this.hiredate = hiredate; &#125; 接下来是hibernate与数据库的连接配置文件hibernate.cfg.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 配置使用的Driver --&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 连接数据库的，设置编码为utf-8 --&gt; &lt;property name="connection.url"&gt; &lt;![CDATA[jdbc:mysql://localhost:3306/users?useUnicode=true&amp;characterEncoding=utf8]]&gt; &lt;/property&gt; &lt;!-- 用户名 --&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;!-- 密码 --&gt; &lt;property name="connection.password"&gt;root&lt;/property&gt; &lt;!-- 配置dialect 方言 告诉hibernate使用的mysql数据库--&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 显示出对应的sql语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- 优化sql语句格式，会自动换行，方便程序员阅读 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;!--create表示mysql如果没有该表则创建，如果有就先删掉再创建,update如果表结构没有改变则会不会删表 就是没有添加新记录就不会创建--&gt; &lt;!--&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;--&gt; &lt;!-- 加载关系对象映射文件 com/ganmy/doman/指的是这个文件所在的包--&gt; &lt;mapping resource="com/ganmy/doman/Employee.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 然后是对象关系映射文件，mvc模型的设计理念是一张表对应一个类，表里面一行对应一个对象，hibernate也是这样设计的，实现对象与数据库表的映射关系的核心文件是类名.hbm.xml，一般这个类名和表名一样，只是首字母大写，我们的表名是employee，那么对应的文件就是Employee.hbm.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping package="com.ganmy.doman"&gt; &lt;class name="Employee" table="employee"&gt; &lt;!-- id元素用于指定主键属性 --&gt; &lt;id name="id" column="id" type="java.lang.Integer"&gt; &lt;!-- generator用于指定主键值生成的策略 使用increment自增长策略--&gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 除了主键的其他属性 property里面的name表示类的属性名，type表示这个属性的类型 ， column里面的name表示表对应的一列，一般设计的时候数据库的结构和类的属性设计一样--&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" not-null="false" /&gt; &lt;/property&gt; &lt;property name="email" type="java.lang.String"&gt; &lt;column name="email" not-null="false" /&gt; &lt;/property&gt; &lt;property name="hiredate" type="java.util.Date"&gt; &lt;column name="hiredate" not-null="false" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 最后是我们的调用，主要是main方法的代码： 123456789101112131415161718192021public static void main(String[] args) &#123; //将configuration configuration主要用来读取配置文件 默认找hibernate.cfg.xml文件 完成初始化 Configuration configuration = new Configuration().configure(); //创建sessionfactory 是一个重量级的接口 SessionFactory sessionFactory = configuration.buildSessionFactory(); //创建一个和数据库的会话 Session session = sessionFactory.openSession(); //对于hibernate而言，做增删改的时候要使用事务提交 Transaction transaction = session.beginTransaction(); //创建一个雇员对象 Employee employee = new Employee(); employee.setName("zhangsan"); employee.setEmail("1556254@123.com"); employee.setHiredate(new Date()); //保存 session.save(employee); //提交事务 transaction.commit(); session.clear();&#125; 这里说明一下： 1、sessionFactory是一个重量级的接口，会占用很多内存，我们要保证一个数据库只对应一个sessionFactory 2、session指的是代码和数据库之间的会话，不是我们javaweb里面的session 3、hibernate设计者设计在对表进行增删改操作的时候要使用事务提交，如果不使用事务提交将无法生效，也不报错，下面是具体的优化，由于sessionFactory是一个重量级的接口，会占用很多内存，我们要保证一个数据库只对应一个sessionFactory，使用静态代码块和单例模式来加载sessionFactory的创建，将sessionFactory封装到一个类里面 123456789101112131415final public class MySessionFactory &#123; //一个sessionFactory对应一个数据库，sessionFactory是一个接口 private static SessionFactory sessionFactory=null; private MySessionFactory()&#123;&#125;; static&#123; sessionFactory = new Configuration().configure().buildSessionFactory(); &#125; public static SessionFactory getSessionFactory()&#123; return sessionFactory; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637 /** * @param args */public static void main(String[] args) &#123; updateEmployee_roll();&#125; /** * 使用回滚的事务提交 */private static void updateEmployee_roll() &#123; //修改用户 //获取会话 Session session = MySessionFactory.getSessionFactory().openSession(); Transaction ts = null; try&#123; ts = session.beginTransaction(); //获取要修改的用户，然后修改,可以通过主键属性获取该对象实例，和表的记录对应 Employee emp=(Employee)session.load(Employee.class, 2); emp.setName("甘明阳11"); emp.setEmail("123@11"); int i = 9/0; ts.commit(); session.close(); &#125;catch(Exception e)&#123; if(ts != null)&#123; ts.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; //关闭session if(session!=null&amp;&amp;session.isOpen())&#123; session.close(); &#125; &#125;&#125; 使用事务模版写最安全，即使报错不会提交到数据库，可以保证数据的完整性，而且能快速定位到错误。 session的获取session的获取方式有两种，分别是openSession()和getCurrentSession()，特点： 1、openSession()是获取一个新的session 2、getCurrentSession()获取和当前线程绑定的线程，换言之，在同一个线程中，我们获取的session是同一个session，这样可以利于事务的控制 3、如果希望使用getCurrentSession()，需要配置hibernate.cfg.xml，添加： 12//thread代表session可以和当前线程绑定&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; 根据实际应用选择使用那个session，如果在同一个线程中，保证要使用同一个session就使用getCurrentSession()，如果在一个线程中要使用不同的session就使用openSession() 4、通过getCurrentSession()获取的session在事务提交以后会自动关闭，通过openSession()获取的session必须手动关闭 5、如果是通过getCurrentSession()获取的session在进行查询的时候也要以事务的方式提交，而且在commit以后，对象获取属性会报错could not initialize proxy - no Session，要在commit之前获取属性 全局事务和本地事务假如我们使用的数据库只有一个，那么控制这个数据库的事务就是本地事务，假如我们连接多个数据库，比如银行的转账系统，从工行转账到农行，那么控制这个跨数据库的事务就被成为全局事务(jta)，全局事务的价值更高 session获取对象的两种方法session获取对象的两种方法分别是get()和load()，他们的区别是： 1、查询没有的数据返回不同，例如一个表只有10行数据，我们去第100行的数据，那么使用get()会返回null，而使用load()会报错ObjectNotFoundExpcetion 2、使用get查询数据会先到session缓存去查然后去二级缓存去查，如果没有立即向数据库发出sql语句，查询到了不会发sql语句。 使用load()去查询，也是先到session缓存去查然后去二级缓存去查，如果没有找到就返回一个代理对象，不会立即向数据库去查，等到后面使用这个代理对象操作的时候，才到DB中去查，这个现象我们称为lazy load(懒加载)，如果用户后来真的要用到这个对象，那么load()回到数据库去查，然后把查询的的结果存放到二级缓存里面，下一次再用这个sql语句去查询还是按照一级缓存、二级缓存的顺序去找，这个时候二级缓存已经有这个数据就不会到数据库去查了，如果二级缓存的命中率很高就会将这个结果放到一级缓存里面。 3、通过修改配置文件可以取消懒加载，在*.hbm.xml里面的class标签添加一个属性laze=”false”就行了 4、如果确定数据库一定有这个对象就使用load()，效率比较高，如果不确定就使用get()，防止报错 一级缓存和二级缓存一级缓存就是sessionfactory的缓存，又叫session级缓存，二级缓存是介于文件和内存之间的缓存，一级缓存不需要配置就可以用，二级缓存需要配置启用才能用，缓存的机制可以减少对数据库的频繁访问，由于hibernate的缓存机制实现的很好，使用hibernate可以优化对数据库查询的次数 线程局部变量模式一般我们的变量范围是一个函数域，但是其实变量是可以和一个线程绑定的，这就是线程局部变量模式，还是以session为例 12345678910111213141516171819202122232425262728293031323334package com.ganmy.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static SessionFactory sessionFactory = null; //threadLocal是本地线程 private static ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;(); //将构造方法私有化 private HibernateUtil()&#123;&#125;; static&#123; sessionFactory = new Configuration().configure().buildSessionFactory(); &#125; //获取全新的session public static Session OpenSession()&#123; return sessionFactory.openSession(); &#125; //获取与当前线程绑定的session public static Session getCurrentSession()&#123; Session session = threadLocal.get(); if(session == null)&#123; session = sessionFactory.openSession(); threadLocal.set(session); &#125; return session; &#125; &#125; 将session放到本地线程threadLocal里面，以后可以直接从threadLocal获取，这样写就不需要配置thread了。 Query接口在hibernate里面的查询使用hql语句，使用hibernate我们只需要写hql语句查询，不需要分数据库，因为hibernate会根据不同的数据库将hql语句翻译成对应的sql语句，例如： 12345678910111213141516171819public static void main(String[] args) &#123; Session session = HibernateUtil.getCurrentSession(); Transaction ts = null; try&#123; ts = session.beginTransaction(); //使用hql语句查询，Employee表示对应的domain对象，id表示domain里面的id属性，不是数据库表里面的列名称 //where后面的条件可以是类的属性名，也可以是表的字段，最好使用类的属性名称 Query query = session.createQuery("from Employee where id = 100"); //通过list方法获取结果，这个list会自动通过反射机制封装成对应的domain对象，不需要进行二次封装 List&lt;Employee&gt; list = query.list(); for(Employee e:list)&#123; System.out.println(e.getName()+e.getEmail()); &#125; &#125;catch(Exception e)&#123; if(ts != null)&#123; ts.rollback(); &#125; &#125; &#125; 使用逆向工程生成配置文件一、使用数据库浏览器连接数据库 1、创建数据库表 2、创建java项目 3、通过myeclipse的数据库浏览器连接到mysql数据库 打开数据库浏览器 -&gt;windows -&gt; open persective -&gt; Myeclipse Database Explorer-&gt;在DB Brower点击右键-&gt; 选择new，创建数据库浏览器连接，然后再到项目，右键 -&gt;myeclipse -&gt; Add Hibernate Annotations 点击Test Driver弹框success表示连接成功 然后在打开右边的项目，找到table，右键，Edit data就可以了 注意mysql5.6的版本不能用5.0的jar包连接，会报错，要用支持5.6的jar包需要使用5.1.25版本的驱动，而且貌似数据库浏览器好像有缓存的样子，我换了一个高版本的jar包还是报错，然后我以为是jar版本不对，陆陆续续在网上找了很多版本的jar包，但是无一例外全部报错，我真的被搞的头都大了，搞了一天没找到原因，后来我思路一转，是不是数据库的问题不是jar包的问题呢，连接我云服务器的mysql，结果可以，然后再连接本地的mysql也都可以了，真的是一脸懵逼的解决了问题。 二、引入hibernate开发包 项目右键-&gt;myeclipse-&gt;add hibernate capabilities，按照如图所示填写 点击Next 点击Next 点击Next 如果希望把hibernate开发包升级，我们可以重新引入包，到文件路径把自动引入的jar包删掉，然后将我们自己的jar包引入 然后我们到数据库浏览器这一边，右键点击表，选择hibernate reverse engineering 点击browse选择包，将domian对象所在的包引入，下一步 、 下一步 然后下一步下一步点finally就可以了 最后：感觉hibernate真的大大提高了程序员的效率，不用写jdbc代码了，是一个值得学习的框架]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jquery做图形单选框]]></title>
    <url>%2Fradio_sum.html</url>
    <content type="text"><![CDATA[今天看了一下开源中国的注册页面，发现他们的性别选择做的很好看，不是使用原生单选框而是使用图片做的，如图： 作为对界面要求高的人，怎么能忍受自己的注册页面还使用原生的单选框呢？ 我开始思考怎么做出这种效果，首先是图片的问题，这个使用截图工具截下来，一共4个图片，然后是显示逻辑，这个使用jquery控制显示和隐藏，改变display的值就可以了，样式实现很简单，然后就是传值的问题，怎么让servlet知道用户的选择呢，有两个方案 1、在js里面设置一个页面变量，sexChecked，值为1表示选中男士，值为2表示选中女士，然后在提交的时候把sexChecked传给servlet就可以了。 2、在html里面写一个隐藏的单选框，用户选中男士的时候让id为manRadio的单选框变为选中状态，选中女生的时候让id为 womanRadio的单选框变为选择状态 由于我是使用form表单提交不是使用ajax提交数据的，form表单提交的时候数据没有经过js这一块，感觉不太好改，还是第二个方案比较简单，不需要改动form表单的参数，我选择第二个方案，代码如下 html代码： 1234567891011121314151617181920&lt;div class="form-group padding_tb5"&gt; &lt;div class="inlineBlock" id="man"&gt; &lt;img src="img/default/man.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;男士&lt;/span&gt; &lt;/div&gt; &lt;div class="inlineBlock hider" id="manHide" onclick="checkSex('1')"&gt; &lt;img src="img/default/noselect.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;男士&lt;/span&gt; &lt;/div&gt; &lt;div class="womanDiv hider" id="woman"&gt; &lt;img src="img/default/woman.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;女士&lt;/span&gt; &lt;/div&gt; &lt;div class="womanDiv margin_l25" id="womanHide" onclick="checkSex('2')"&gt; &lt;img src="img/default/wonoselect.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;女士&lt;/span&gt; &lt;/div&gt; &lt;input type="radio" name="sex" value="1" id="manRadio" checked="checked"&gt; &lt;input type="radio" name="sex" value="2" id="womanRadio"&gt;&lt;/div&gt; js代码： 12345678910111213141516//性别选择判断function checkSex(id)&#123; if(id=="1")&#123; $("#manHide").css("display","none"); $("#man").css("display","inline-block"); $("#womanHide").css("display","inline-block"); $("#woman").css("display","none"); $("#manRadio").attr("checked","checked"); &#125;else if(id=="2")&#123; $("#womanHide").css("display","none"); $("#man").css("display","none"); $("#woman").css("display","inline-block"); $("#manHide").css("display","inline-block"); $("#womanRadio").attr("checked","checked"); &#125;&#125; 这里出现了一个很神奇的问题，这个单选框居然只能改动一次，一开始我以为是没有进入if判断，使用console.log()打印却能打印出来，jquery里面的id也没有写错，代码看起来完全没有问题，这下我有点懵逼了，在网上找来找去也没有找到类型的问题，难道是不能给checked的值使用checked吗？我改成了false和ture，还是一样只能改动一次，几个假设都被推翻，确实很头疼，这个时候我想了一下，为什么第一次可以改动，肯定是这两个radio有什么不一样的地方，好像第一个radio一开始是checked的状态的，我把这个属性去掉了，再测试可以改动两次了，果然radio的checked会影响jquery的改动，改变下一个radio的时候去掉上一个radio的checked属性不就可以了吗，我加了一句remove的代码，果然可以改动啦，html还有这么神奇的地方真是的，改动如下 1234567891011121314151617181920//性别选择判断function checkSex(id)&#123; if(id=="1")&#123; $("#manHide").css("display","none"); $("#man").css("display","inline-block"); $("#womanHide").css("display","inline-block"); $("#woman").css("display","none"); //改变下一个radio的时候要移除已经选中的radio $("#womanRadio").removeAttr("checked"); $("#manRadio").attr("checked","checked"); &#125;else if(id=="2")&#123; $("#womanHide").css("display","none"); $("#man").css("display","none"); $("#woman").css("display","inline-block"); $("#manHide").css("display","inline-block"); //改变下一个radio的时候要移除已经选中的radio $("#manRadio").removeAttr("checked"); $("#womanRadio").attr("checked","checked"); &#125;&#125; 这样改动就可以了，功能成功实现，效果如下： 总结：平时做项目的时候要多思考，遇到问题仔细分析，多看看别人的技术博客，这样才能进步得更快。页面跳转传送门]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>radio</tag>
        <tag>checked</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数深入研究]]></title>
    <url>%2Fjavascript_start.html</url>
    <content type="text"><![CDATA[javascript入门容易精通难，由于语法比较松散，很多用法需要我们自己去研究，这段时间我主要是研究js函数的使用 使用函数作为参数在js里面函数也是一种数据类型，我们可以使用函数作为另外一个函数的参数，例如： 123456789101112//定于被调用的函数function hello()&#123; for(var i=0;i&lt;5;i++)&#123; console.log(i); &#125;&#125;//定义去调用的函数function go(fn)&#123; window[fn].call(this);&#125;//调用，这里直接写hello就可以啦，后面不用小括号哦go(&quot;hello&quot;); 使用函数(带参)作为参数感觉上述方法在实际效果中并不好用，因为实际情况一般都有参数，下面来介绍一个带参数函数的使用 1234567891011//定义主动调用函数function test1(value,Func)&#123; Func(value)&#125;//定义被调用函数function test3(data)&#123; alert(data);&#125;//去调用test1(&apos;22&apos;,test3); 在test1里面有两个参数，被调用函数的参数，和调用函数， ajax封装将上面的知识引申到实际代码里面，比如说ajax方法的封装 下面是一个ajax的基本使用： 123456789101112131415161718$.ajax(&#123; //这是请求的servlet url: &quot;hqyzm&quot;, //这里定义请求类型 method: &quot;post&quot;, //这里是前端要传给后台的数据 data: &#123; phone: &quot;12345678912&quot; &#125;, //这里是请求成功调用的方法 success: function(data)&#123; console.log(data) &#125;, //这里是请求失败调用的方法 error: function(data)&#123; alert(&quot;网络繁忙，请稍后重试。&quot;); &#125; &#125;) 项目会大量的调用ajax，如果每次我们都去单独写ajax会让项目代码非常臃肿，我们应该将ajax封装起来，可以根据上面的知识来封装ajax 思路分析ajax主要有三个地方会变化：1、请求的servlet 2、传给servlet的参数 3、请求成功调用的方法。 我们可以用变量代替这些数据，下面是一个注册查询数据库是否已存在用户名的ajax请求 123456789101112131415161718192021222324252627//封装一个ajax方法，这里execute是请求成功执行的方法//servlet是去请求的servlet，val传过去的参数function to_ajax(execute,servlet,val)&#123; $.ajax(&#123; url: servlet, method: &quot;post&quot;, data: &#123; username: val, &#125;, success: function(data)&#123; execute(data) &#125;, error: function()&#123; alert(&quot;网络繁忙，请稍后重试。&quot;) &#125; &#125;)&#125;//定义ajax请求成功执行的方法function check_name_to_db(data)&#123; if(data==&quot;0&quot;)&#123; $(&quot;#name_detail&quot;).html(&quot;该称呢已被注册&quot;); $(&quot;#title_name&quot;).css(&quot;display&quot;,&quot;block&quot;); name_status = 0; &#125;&#125;//调用这个ajax方法to_ajax(check_name_to_db,&quot;Checkname&quot;,&quot;zhangsan&quot;); 这个函数还可以进一步封装，主要在于参数的传送，毕竟每次ajax传送的参数数量都不一定相同，要解决这个问题需要运用java面向对象的思维，将参数作为一个对象传送给服务器端，例如上传文件的时候将参数封装到FormData对象里面 12345var formdata = new FormData();//想formdata里面添加数据formdata.append("file",file);//调用ajax方法up_ajax(req_success,"Mybook",formdata) 参数的封装js函数的参数都是封装到一个名为arguments的数组里面，里面按照从前到后顺序存放参数，例如： 12345678//定义被调用的函数function say()&#123; console.log(&apos;Hello&apos; + arguments[0] + arguments[1] + arguments[2]); console.log(arguments.length);&#125;//调用函数say(&quot;World！&quot;, &quot;ByeBye!&quot;,&quot;gogo!!&quot;); 控制台打印结果是HelloWorld！ByeBye!gogo!!，由此可见，我们使用函数的时候可以写10个8个实参，但是定义的时候 不写形参也可以。 最终封装结果，封装了一个上传组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445//下面是上传文件使用的ajax方法function up_ajax(execute,servlet,val_data)&#123; $.ajax(&#123; url: servlet, method: "post", data: val_data, //将datatype改为text放在上传成功却进入error方法 dataType : "text", processData: false, // 注意：让jQuery不要处理发送的数据 contentType: false, // 注意：让jQuery不要设置contentType请求头 success: function(data)&#123; execute(data); &#125;, error:function()&#123; alert("网络繁忙，请稍后重试！") &#125; &#125;)&#125;function upload_book()&#123; //$("#upload_book").prop("files")是获取files属性的值，返回的结果是一个数组 //这个数组里面有两个键值对 0:file,length:1，通过key为0获取file文件 //file是一个file对象，里面封装了上传的文件的各种属性 var file = $("#upload_book").prop("files")["0"]; //获取文件的大小，将单位转为m var size = file.size/1024/1024; //如果上传文件的大小超过3M就不让上传 if(size&gt;3)&#123; alert("上传文件过大"); &#125;else if(size&lt;=0)&#123; alert("不能上传空文件"); &#125;else&#123; //由于上传的是二进制文件，需要创建FormData对象 var formdata = new FormData(); //想formdata里面添加数据 formdata.append("file",file); //调用ajax方法 up_ajax(req_success,"Mybook",formdata) &#125;&#125;//上传成功调用function req_success()&#123; var data = arguments[0]; console.log(data);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java发送手机短信认证码]]></title>
    <url>%2Fjava_yzm.html</url>
    <content type="text"><![CDATA[一直都有个技术梦想，做出属于自己的门户网站，业余时间都投入网站建设里面，由于网站需要手机认证来实现手机号找回密码功能，对于短信认证码的需求非常强烈，经过几天的研究，终于实现了这个功能(开心)，下面记录一下： 准备工作​ java上要实现短信认证码的功能，首先要具备一下几点条件： ​ 1、实名认证的阿里云账户 ​ 2、已认证的短信签名和短信模版 ​ 3、云服务器密钥 ​ 4、配置完整的tomcat以及servlet环境 ​ 5、阿里云配套的短信功能jar包 实名认证的阿里云账户需要你自己去搞定，作为一名有激情的后台开发工程师，云服务器对你的好处非常大，除了短信服务，还有其他好用的功能，像人脸识别，图形功能等等。这里我假定你已经有了可用的阿里云账户。主要介绍剩下的4点： 短信签名和短信模版首先我们要了解短信签名和短信模版的概念，短信签名是短信前缀，一般是网站名称或者用户名称，短信模版就是短信的内容，如下图，短信签名是”明阳图书”，短信模版就是后面一长串的内容 由于互联网环境监管严格，我们网站发送的短信内容都需要结果审核，不然就无法发送哦，下面是具体步骤： 登录阿里云帐号，在搜索栏输入”短信服务” 选择立即开通，由于我已经开通了，样式和你不一样 开通短信服务后找到管理控制台 点击签名管理 点击右上角添加签名 后面的内容也没啥可说的，按照官网提示填写内容，提交审核就行了，一般两个小时就有结果啦，短信模版步骤也是一样的 云服务器密钥云服务器密钥是包括两个部分，Access Key ID和Access Key Secret，这相当于你阿里云的账户和密码，和普通帐号的使用场景不同，对你的阿里云拥有最高的权限，所以千万不要把自己的密钥透露给别人哦！ 点击接口调用，获取AK 点击右上角的创建AccessKey 将创建的密钥保存到桌面，待会备用 tomcat以及servlet环境这个我之前的博客有详细的介绍，传送门 短信功能jar包阿里云短信服务需要两个jar包，可以去阿里云官方sdk下载，我这里也有提供，点击下载，密码：fjhx 下完将jar包导入到你的web项目中，注意要先把jar包复制到web目录里面再导入，不然上了生产环境会找不到jar包 好啦，所有的准备工作都已经完成，下面我们在java里面调用，按照注释修改即可，无需修改的地方不要动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.exceptions.ServerException;import com.aliyuncs.http.MethodType;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.profile.IClientProfile;//发送短信认证码public class Util_fsdx &#123; public static String get_code(String phone) throws ServerException, ClientException&#123; //验证码 String code = "123456"; //设置超时时间-可自行调整 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化ascClient需要的几个参数 final String product = "Dysmsapi";//短信API产品名称（短信产品名固定，无需修改） final String domain = "dysmsapi.aliyuncs.com";//短信API产品域名（接口地址固定，无需修改） //替换成你的AK final String accessKeyId = "XXXX";//你的accessKeyId final String accessKeySecret = "XXXX";//你的accessKeySecret //初始化ascClient,暂时不支持多region（请勿修改） IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象 SendSmsRequest request = new SendSmsRequest(); //使用post提交 request.setMethod(MethodType.POST); //必填:待发送手机号。支持以逗号分隔的形式进行批量调用，批量上限为1000个手机号码,批量调用相对于单条调用及时性稍有延迟,验证码类型的短信推荐使用单条调用的方式；发送国际/港澳台消息时，接收号码格式为00+国际区号+号码，如“0085200000000” request.setPhoneNumbers("XXXX"); //必填:短信签名-可在短信控制台中找到 request.setSignName("XXXX"); //必填:短信模板-可在短信控制台中找到 request.setTemplateCode("XXXXX"); //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 //友情提示:如果JSON中需要带换行符,请参照标准的JSON协议对换行符的要求,比如短信内容中包含\r\n的情况在JSON中需要表示成\\r\\n,否则会导致JSON在服务端解析失败 request.setTemplateParam("&#123;\"code\":\""+code+"\"&#125;"); //可选-上行短信扩展码(扩展码字段控制在7位或以下，无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("yourOutId"); //请求失败这里会抛ClientException异常 SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); if(sendSmsResponse.getCode() != null &amp;&amp; sendSmsResponse.getCode().equals("OK")) &#123; //请求成功 System.out.println("请求成功，验证码是" + code); &#125; return code; &#125; 说明由于阿里云只是负责发送给用户手机，不会返回验证码给后台，所以我们需要先用java后台生成短信验证码，可以使用Math类里面的random()生成6个0到10之间的随机整数拼接为一个验证码，这个我也为你写好啦 12345//生成验证码 String code = ""; for(int i=0;i&lt;6;i++)&#123; code = code + (int)(Math.random()*10); &#125; 由于后台很多servlet需要用到短信服务，我建议你将以上代码封装为一个静态方法，以后就可以多次调用了哦！ 同一个签名对同一个手机号发送验证码是有限制的，5分钟以内3条，1个小时以内5条，24个小时以内10条，这个时间间隔是以发送上限条数的时间点为准的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录建站遇到的各种问题]]></title>
    <url>%2Fjava_project.html</url>
    <content type="text"><![CDATA[中文乱码导入html文件乱码用过sublime text3后我就迷上了sublime的快捷键，相比之下用myeclipse写感觉好慢，所以一般前端代码我都是用sublime写完后再导入到myeclipse里面，但是有的时候会有中文乱码的现象，由于myeclipse默认使用GBK的编码，我们需要改为 utf-8才能正常使用，有两处地方要改 1、改变servlet项目的编码为utf-8 右键项目，选择Priperties，搜索Resource，改变编码为utf-8 2、改变myeclisp的编码为utf-8 ，找到window -&gt; preference -&gt;general -&gt;workspace，将编码改为utf-8 这里也顺便解决了另外一个问题，就是js文件报错的问题 myeclipse打开html文件缓慢由于myeclipse默认使用可视化打开，所以会消耗不少时间，我们需要改变打开方式 有两种方式 1、右键文件openwith -&gt;MyEclipse HTML Editor 2、改变默认打开方式 window -&gt; preference -&gt; 搜索file 找到File Associations,如图 选中html文件，然后在下方框框里面选择MyEclipse HTML Editor,点击Default，就可以啦 其他的文件觉得慢也可以按照这种思路做相应的改动 JDBC插入数据报错查询的时候使用 1stmt.executeQuery(sql); update或者insert操作的时候，使用 1stmt.execute(sql); 数据库乱码我之前插入数据的时候，数据的中文数据变成了？？？，在网上找了半天，发现网上很多答案有错误，这里指正一下 思路是在getConnection()里面增加两个设置编码的参数，useUnicode和characterEncoding 1conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/users?useUnicode=true&amp;characterEncoding=utf8"); 但是网上很多答案都把characterEncoding=utf8写成了characterEncoding=utf-8，搞了我好久，这里特别强调一下。 网站速度慢在网站注册功能，登录功能和个人主页功能完成的时候，我发现了一个问题，网站速度慢，Google了一下，才发现我的请求全部用的重定向(头疼)，当初建站的时候没注意这一点(伤心) 这里说明一下请求重定向和请求转发的区别，比如说从a.servlet到b.servlet 重定向走的路： 浏览器-&gt;a.servlet-&gt;浏览器-&gt;b.servlet 转发走的路：浏览器 -&gt; a.servlet -&gt; b.servlet 重定向明显走的路多一点，这还只是一个流程，如果有多个流程，那速度简直是天差地别啦 下面总结一下重定向和转发的特点： 请求转发：请求转发的过程全部会在服务器完成，经过多个servlet流程浏览器也看不到，明显比较安全，而且每次转发都会把当前request和response域对象传过去，所有流程都是用的同一个request和response对象，数据好取，而且由于不用通知客户端，速度明显快很多，就是不能请求外部服务器。 请求重定向：可以请求外部服务器，由于我的站点不用请求别的服务器，这一点跟没有一样，可以说被请求转发全方面碾压。 浏览器上方url会改变，由于浏览器url改变我们的servlet不会暴露出来，对于服务器安全性有很大的提高，建议后台的最后一个请求使用重定向，前面所有请求用转发 注意：改了请求方式后在jsp要指定meta的href的值，不然会找不到样式，因为请求转发不会通知浏览器地址改变，也就是说浏览器用的地址一直都是第一个servlet的地址，下面是解决方法： 步骤一：在jsp上面加上这两句话 12String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; 步骤二： 在jsp的head标签里面要加&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;标签 request.getScheme()表示站点使用协议 request.getServerName()表示站点主机，本地就是localhost request.getServerPort()表示站点端口号 request.getContextPath()表示站点项目名称 最后的basePath是一个完整的url，比如我的url是： 1http://localhost:8080/servletPro/ 然后将href指定为这个地址，以后写相对路径就是相对这个地址来的 java流换行问题使用java流操作文件的时候，发现缓冲字符流BufferedWriter里面有一个方法readLine()可以一行一行的读取数据，相比FileWriter一个字符一个字符的读取快了很多，但是不会读取换行符号，需要我们手动添加换行符，由于在不同的操作系统上换行符不同： 123mac: \r linux: \nwindow: \r\n 可以使用java里面的System.getProperty(“line.separator”)自动获取空格来解决这个问题 myeclipse优化一直感觉myeclipse很卡，后来发现原来，myeclipse开启了很多不必要的插件和语法检查，记录一下优化方法 1、去掉js语法检查 window-&gt;Preferences，在搜索栏输入Validation，把javascript的两个勾去掉 2、去掉启动插件选项 window-&gt;Preferences，在搜索栏输入Startup and Shutdown ,这里以MyEclipse EASIE开头的都是myeclipse支持的服务器插件，由于我只用tomcat，把除了tomcat的服务器插件都关掉 WTP ：一个跟myeclipse差不多的东西，主要差别是 WTP 是免费的，如果使用myeclipse，这个可以取消 Mylyn：组队任务管理工具，类似于 CVS ，以任务为单位管理项目进度，没用到的可以取消Derby：一种保存成 jar 形式的数据库，我没用到，取消 3、取消拼写检查 没什么用处，可以去掉 windows–&gt;perferences，搜索spelling 修改项目名称报404javaweb项目修改了项目名称是不够的，还需要去配置文件修改一下 项目上右击鼠标–&gt;Properties–&gt;MyEclipse–&gt;Web–&gt;Content Root–&gt;Web content-root–&gt;改成你想要的项目名 即可 myeclipse搜索功能的使用顶部工具点击search-search或者CTRL+H，在搜索界面，选择filesearch，然后图中对应的位置输入要搜索的内容，点击下方搜索按钮就可以了。 junit单元测试Junit测试是程序员测试，即所谓白盒测试，以最小单元测试即函数测试，Junit是一套框架，继承TestCase类，就可以用Junit进行自动测试了。新版本的myeclipse内部集成了单元测试，但是有的ide是没有这个功能的，这个时候我们就需要自己去导入这个功能。 其实很简单，到网上下载junit包，然后导入项目就可以了，注意这个导入和spring包不一样不能直接粘贴，要使用buildPagh导入。然后在要测试的函数上面写上注解@Test导入相关包就可以测试了 注意了如果自己的java文件有名字叫Test的会冲突，报错test is not an annotation type 项目启动前存数据到servletContext里面1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;contextConfigLocationValue&gt;&lt;/param-value&gt; &lt;/context-param&gt; 获取： 123456如何使用页面中$&#123;initParam.contextConfigLocation&#125;Servlet中String paramValue=getServletContext().getInitParameter("contextConfigLocation") init-param与context-param区别定义param-name: 1234 &lt;context-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;user&lt;/param-value&gt;&lt;/context-param&gt; context-param使用方法：由于context-param是配置在web下面，属于上下文参数，在整个环境中都可使用，存放在getServletContext对像中，因此使用方法是：getServletContext().getInitParameter(“user”)，如： 12345public void service(HttpServletRequest request, HttpServletResponse response)throws ServletException,IOException&#123; String user=getServletContext().getInitParameter("user"); System.out.println(getServletContext().getInitParameter("user")); System.out.println(user); &#125; init-param使用方法：由于init-param是配置在servlet中，属于某一下servlet，存放在getServletConfig中，因此使用方法是：getServletConfig().getInitParameter(“user1”); 由于它属于当前的servlet类，所以用this替代getServletConfig(), 使用this.getInitParmeter(“user1”) , 如： public void service(HttpServletRequest request, HttpServletResponse response)throws ServletException,IOException{ String user=getServletContext().getInitParameter(&quot;user1&quot;); System.out.println(getServletConfig().getInitParameter(&quot;user1&quot;)); //或this.getInitParmeter(&quot;user1&quot;); System.out.println(user1); } 总结： context-param在所有的servlet中都能使用，init-param只能在当前的servlet中使用，如果不在当前的servlet中使用，取的值为null 新建的web工程找不到javax.servlet.http.httpservlet路径是：跳转]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器ECS建站攻略]]></title>
    <url>%2Faly_java_tomcat.html</url>
    <content type="text"><![CDATA[最近买了阿里云的ECS产品，之前一直没有建站，因为我以为要先备案才能访问服务器，浪费了大半个月的时间(捂脸)。 这里先纠正一下概念，不管有没有备案，买了服务器就可以搭建自己的网站，只是地址不好记住，比如说我的地址是 43.25.118.37，那我的网站地址可能是 1http://43.25.118.37:8080 如果我购买了一个域名ganmyds.cn，成功备案并且解析到43.25.118.37上,那我的网站地址就是 1http://ganmyds.cn:8080 这样相对来说比较好记住。 由于我是学java的，自然建站后台也是选择java环境，这里强调一下我的环境 linux系统centos6.8 64位+jdk1.8.0+tomcat8.0 其他环境这里就不说了，下面开始环境搭建流程： ECS管理软件下载这里推荐两款软件用来管理ECS服务器，使用xshell远程连接终端，用xftp可以从你的电脑传文件到云服务器上 下载： xshell xftp 软件使用方法双击xshell.exe，新建会话 帐号密码没有输错就可以进入，然后我们要传文件的话，点击传输新文件就可以打开xftp 这里xftp的地址和你的linux地址是一致的，假如你想传文件到/usr/java/tomcat/里面，可以在xshell里面先切换到这里去 1cd /usr/java/tomcat/ 然后在点击传输新文件就可以快速传输文件了 环境搭建由于tomcat是用java写的，所有我们肯定要先搭建java环境，下载jdk 下载tomcat 创建目录12345cd /usr mkdir javacd javamkdir tomcatmkdir jdk 然后我们把jdk-8u171-linux-x64.tar.gz.tar.gz.tar.gz放到jdk里面，把apache-tomcat-8.5.31.tar.gz放到tomcat里面 配置jdk环境变量123cd jdktar -zxvf jdk-8u171-linux-x64.tar.gz.tar.gz.tar.gzvi /etc/profile 在里面对应路径加上下面内容 1234export JAVA_HOME=/usr/java/jdk/jdk1.8.0_171export JRE_HOME=/usr/java/jdk/jdk1.8.0_171/jreexport CLASSPATH=.:$JAVA_HOME/lib$:JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin/$JAVA_HOME:$PATH 如图： 退出登录 1logout 关闭xshell重新打开就可以了 1java -version 如图就表示成功了 安装tomcat1234cd /usr/java/tomcat/tar -zxvf apache-tomcat-8.5.31.tar.gzcd apache-tomcat-8.5.31.tar.gz/binvi setclasspath.sh 在最下面加上内容 12export JAVA_HOME=/usr/java/jdk/jdk1.8.0_171export JRE_HOME=/usr/java/jdk/jdk1.8.0_171/jre 启动tomcat 1./startup.sh 有Tomcat started就表示成功启动 然后在浏览器输入http://云服务器的ip:8080就可以访问了 好的，服务器终于搭建好了，由于tomcat默认是8080端口，我们的网站需要输入端口号，这个对于网站的推广是不好的，我们现在改为80端口 修改配置文件在window上只需要编辑tomcat/conf/server.xml，找到 123&lt;Connector URIEncoding="UTF-8" port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 把port改为80就可以了 假如你的用户不是root这样不行，因为linux上非root用户不能监听1024以下的端口号，我们可以用linux的端口转发机制，输入 1iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 保存 1service iptables save 安全组改动如图修改 按如图填写 还要配置8080的端口 重启tomcat我们改动了配置文件需要重启tomcat才能生效，但是在linux上只能通过结束进程的方式关闭tomcat，我们得先找到tomcat的进程id，由于tomcat默认监听8080，我们可以通过这一点来找 1netstat -anp | grep 8080 找到对应的进程编号，如图是我的进程编号，5881 结束5881就可以了 1kill -9 5881 然后启动就可以了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的的bootstrap学习之路]]></title>
    <url>%2Fbootstrap_summed.html</url>
    <content type="text"><![CDATA[使用bootstrap框架开发可以极大的提高开发效率，bootstrap有以下优点： 1、响应式设计，bootstrap的设计无时不刻都是适应移动端的，我们不需要再特地写响应式了，提高效率 2、浏览器兼容，我以前就喜欢bootstrap这一点，我不会用bootstrap的时候会引用normalize.css，normalize.css是从bootstrap剥离专门做浏览器兼容的问题。 3、不需要自己取名字，说实话类名真的不好取，bootstrap里面把类名都给我们写好了，直接引用就可以了 由于bootstrap要记太多东西了，好记性不如烂笔头，我打算用这篇文章记录bootstrap的一些常用内容。方便开发的时候直接查阅 引用bootstrap点击下载 我用的是版本是3.3.5。 栅格系统bootstrap将屏幕分为12等分，类名前面都co-为前缀,col的全称是column，中文翻译是列，例如想要4等分，每一份长度是屏幕宽度的三分之一就用col-md-3 123456789101112&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. &lt;/div&gt;&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt;&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. &lt;/div&gt;&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; 这个样式是响应式布局的，在手机上自动变为摞起来的样式，假如想让响应式布局生效的范围更小，只需要改md就行 范围从大到小依次是： 1234col-lg-3 //lagrecol-md-3 //mediumcol-sm-3 //smallcol-xs-3 //extra small 用的最多的是md和sm，一般很少用xs，因为xs不管屏幕多小都不会应用相应式。还是感觉这个bootstrap的栅格系统非常强大，原来不用bootstrap的时候我要实现这个功能要写不少的代码，现在直接引用就可以了。 表单表单在网页上的应用是非常多的，基本上每个网站都有登录注册输密码的页面，这些页面都是用表单做的。下面是一些例子： 常用表单：1234567891011&lt;form class="container" style="max-width: 550px;"&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;div class="form-group"&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="password" class="form-control"&gt; &lt;/div&gt;&lt;/form&gt; 效果如图： 这里最重要的样式就是form-control，给input用的，form-group的只是是添加15px的margin-bottom。 内联表单12345678910111213&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="form-inline"&gt; &lt;h1 style="margin-bottom:15px;"&gt;注册&lt;/h1&gt; &lt;div class="form-group"&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 这个样式只是多嵌套了一层form-inline的div，并且在手机上面和上面显示一样，感觉更加具有通用性 验证结果表单12345678910111213&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="form-inline"&gt; &lt;h1 style="margin-bottom:15px;"&gt;注册&lt;/h1&gt; &lt;div class="form-group has-error"&gt; &lt;label class="control-label"&gt;姓名&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 另外bootstrap还提供了其他验证结果的样式，比方说验证成功是has-success，验证警告是has-warning。 充值金额表单123456789&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="form-group"&gt; &lt;label style="margin-top: 15px;"&gt;充值金额&lt;/label&gt; &lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;￥&lt;/div&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 效果如图： 密钥表单12345678910111213141516&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="row" style="margin-top: 15px;"&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 效果如图： 这种表单结合了通用表单和栅格系统，其实和上面差不多。 按钮一般按钮相比表单，按钮的应用更广，几乎所有页面都有按钮，按钮的处理也相对简单，bootstrap提供了5种情况的按钮，分别是 12345&lt;button class="btn btn-default"&gt;你好&lt;/button&gt; //默认按钮&lt;button class="btn btn-primary"&gt;你好&lt;/button&gt; //主色调按钮&lt;button class="btn btn-danger"&gt;你好&lt;/button&gt; //危险按钮&lt;button class="btn btn-warning"&gt;你好&lt;/button&gt; //警告按钮&lt;button class="btn btn-info"&gt;你好&lt;/button&gt; //信息按钮 代码： 123456789&lt;form class="container" style="max-width: 550px;"&gt; &lt;div style="margin-top:15px;"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-primary"&gt;你好&lt;/button&gt; &lt;button class="btn btn-danger"&gt;你好&lt;/button&gt; &lt;button class="btn btn-warning"&gt;你好&lt;/button&gt; &lt;button class="btn btn-info"&gt;你好&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 效果如下： 其他标签像a标签和input的submit标签也可以使用这些样式，大小也是可以调整的。 12345678910&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="margin-t15"&gt; &lt;button class="btn btn-default btn-lg"&gt;你好&lt;/button&gt; &lt;button class="btn btn-primary"&gt;你好&lt;/button&gt; &lt;button class="btn btn-danger"&gt;你好&lt;/button&gt; &lt;button class="btn btn-warning btn-sm"&gt;你好&lt;/button&gt; &lt;button class="btn btn-info btn-xs"&gt;你好&lt;/button&gt; &lt;button class="btn btn-block btn-danger" style="margin-top: 15px;"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 在手机银行的项目上btn-block用的最多。 按钮组在很多后台项目像什么管理平台会用到按钮组，这里也写一下： 123456789101112131415161718192021222324252627282930&lt;form class="container" style="max-width: 550px;"&gt; &lt;!--按钮组--&gt; &lt;div class="margin-t15"&gt; &lt;div class="btn-toolbar"&gt; &lt;!--按钮组是btn-group--&gt; &lt;div class="btn-group btn-group-lg"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;div class="btn-group"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;div class="btn-group btn-group-sm"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="margin-top:15px;"&gt; &lt;div class="btn-group-vertical"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 下面默认添加样式 1234body&#123; max-width: 400px; margin: 20px auto;&#125; 导航关于导航栏，主要有下面4种： 知乎导航123456789&lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor.&lt;/div&gt; 效果如下： 这里说明一下，在nav-tabs后面加上nav-justified的类可以是导航按钮变得更宽 123456789&lt;ul class="nav nav-tabs nav-justified"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor.&lt;/div&gt; 效果如下： 普通导航123456789&lt;ul class="nav nav-pills"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor.&lt;/div&gt; 效果如下： 侧边栏导航123456789101112131415&lt;div class="row"&gt; &lt;div class="col-xs-4"&gt; &lt;ul class="nav nav-pills nav-stacked"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="col-xs-8"&gt; &lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor. &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 其实这个只是普通导航和栅格系统的组合使用 导航栏1234567891011121314151617181920&lt;div class="navbar navbar-default"&gt; &lt;div class="navbar-header"&gt; &lt;div class="navbar-brand"&gt;名言网&lt;/div&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;button class="btn btn-danger" type="submit"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果如图： 由于导航栏需要占据屏幕整宽，这里没有限制body宽度，在navbar里面使用navbar-left或者navbar-right实现左对齐或者右对齐 面板1234567891011&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt;用户统计&lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Blanditiis aperiam nostrum, hic voluptas, consequatur magni libero fugiat architecto at, excepturi quis distinctio, laboriosam eos. Ipsam voluptates maiores possimus magnam animi. &lt;/div&gt; &lt;div class="panel-footer"&gt; &lt;div class="small text-muted"&gt;数据更新于5秒前&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 这里text-muted和small主要是将字号变小并且改变颜色的，并且panel-default可以改成panel-success或者panel-warning 表格和表单不同，表格适用于统计信息的 12345678910111213141516171819202122232425262728293031&lt;table class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;联系方式&lt;/th&gt; &lt;th&gt;注册于&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class="danger"&gt; &lt;td&gt;wanghuahua&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;tr class="success"&gt; &lt;td&gt;你阿飞&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;tr class="warning"&gt; &lt;td&gt;235432&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;tr class="info"&gt; &lt;td&gt;sgsg&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 效果如下： table-striped是用来加重基数行的颜色的，这里由于全部加上了颜色没有表现出来，可以改为table-hover用来相应鼠标滑动效果，想要边框可以在table里面添加类table-bordered 翻页123456789&lt;ul class="pagination"&gt; &lt;li&gt;&lt;a href="#"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;...&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;50&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 效果如下 还有一种简单的翻页效果，主要是用于页数比较少的 1234 &lt;ul class="pager"&gt; &lt;li&gt;&lt;a href="#"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="#"&gt;下一页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 效果如下： 文章头部12345 &lt;div class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;文章列表&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;yo. world &lt;span class="badge"&gt;15k&lt;/span&gt;&lt;/li&gt;&lt;/div&gt; 效果如下： 列表123456 &lt;div class="list-group"&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt;&lt;/div&gt; 效果如下： 这种列表主要是用作侧边栏的 标签12345&lt;p&gt; &lt;span class="label label-success"&gt;面霜&lt;/span&gt; &lt;span class="label label-info"&gt;water baby&lt;/span&gt; &lt;span class="label label-danger"&gt;http&lt;/span&gt;&lt;/p&gt; 效果如下： 这种标签可以完美的嵌入文字中间]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客绑定域名]]></title>
    <url>%2Fhexo_realm.html</url>
    <content type="text"><![CDATA[刚开始接触hexo博客的时候，感觉非常惊奇，尤其是next主题自带的各种方便的功能，但是部署到github上面一直都有一些不满意的地方，觉得github的域名不好，主要有以下几个问题： 1、.github.io是二级域名，始终有种寄人篱下的感觉，是github上的附属域名 2、地址太长，像我之前的博客地址是： 1ganmyds.github.io/hexo_blog/ 我自己都记不住，就别说别人了。 3、.github.io不支持收录到百度上，也就是说你的博客别人搜索不到，这样博客基本就失去了一半的价值了 4、没有自己的域名很多功能不能实现，比方说网站浏览数，评论功能 所以我的域名备案好了之后马上就开始搞域名的调整，记录一下： 添加域名解析进入阿里云服务器管理平台，找到域名管理，点击添加解析 按照图片上的说明输入就可以了。 本地修改进入你的博客地址，找到source文件夹，创建一个CNAME文件,右键gitbash 1vi CNAME 然后键盘输入i,输入域名，保存，和linux的vi操作一样，然后hexo g，部署到github上就可以了，注意： 1、CNAME没有后缀，所以你最好用git来创建，不要创建一个txt文件然后把名字改成CNAME，这样很容易忘记去掉后缀，特别是有的电脑不显示后缀更麻烦 2、内容没有什么http:www，写域名部分就可以了，例如我的域名全称是 1http://ganmyds.cn 那我输入的部分就是ganmyds.cn github修改进入你的博客的github路径，找到setting 搜索Custom domain，把值改为你的域名，如图所示： 如果没有操作好，就会出现404报错，如图所示 网上很多绑定博客的教程都没有第三步，所以这里重点说明一下，有什么不懂的可以在评论里面说明哦！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的阿里云备案经历]]></title>
    <url>%2FAlibabaCloud.html</url>
    <content type="text"><![CDATA[以前和同事一起做过一个网站项目，当时我负责前端页面搭建，他负责后端php系统，网站放在京东云上运行，那时候对云服务器有一丝好奇，无奈复用太贵，一直没买，后来群友发我一个链接，是阿里云优惠活动，活动时间是3月28号到4月13号，新用户专享，1年99，两年189，3年279，要知道没有活动的时候阿里云一个月的费用都要70多，我毫不犹豫的买了3年的服务器，一口气便宜了3300多，买服务器为了自己以后更好的学习吧！当时我也没想到备案花了我这么多的时间，先谈谈备案流程！ 备案流程注册域名​ 我们买了云服务器就自动得到一个公网ip地址，像百度的公网ip地址是 http://14.215.177.39/ ​ 一般这个ip地址非常不利于吃瓜群众记住，所以大部分网站都会注册一个域名，然后通过DNS服务实现域名和ip地址的绑定，这就是所谓的域名解析，注册域名的地址：传送门，一般com域名最贵,那些很长的后缀像什么club、online等等的域名就很便宜了，六七块钱一年，我最后还是选择了cn的后缀，也不贵而且相对较短，29元一年，反正几百都出了也不在乎这几十块了。 填写信息初审这里一般都要写准确的信息，像电话到时候会有阿里云那边的人打电话验证是不是你本人，然后地址要具体到房间号，非常严格的哦，所以为了不麻烦我们还是写清楚一些，这里要注意网站类型千万别写论坛，基本上论坛都会被各种理由拒绝的，还有网站名称不要带有工作室等等看起来很商业化的名称，我的网站类型是博客，网站名称是学习和成长，这样相对比较好通过审核，一般初审一个工作日就有结果了，我的初审经历非常坎坷，挂了两次(捂脸) 上传资料这一步就到了大家说的幕布阶段了，不过得益于技术的发展，广东、上海、重庆、辽宁、安徽、福建这些省份不用拍幕布上传了，只需要下载阿里云app，按照指示拍摄几个表情就可以了，非常方便。其他的省份还得申请幕布，当然幕布的申请是免费的，你不用出一分钱，但是还是很麻烦，而且要求很多，背景要被幕布完全覆盖、人得在幕布正中间、要拍出上半身、不能Ps等等 管局审核前面两次审核都是阿里云那边做的，这里就是有关部门审核的了，果然有关部门还是比较慢的，我是5月3号提交审核的，一直到5月11号才出结果，一共花了9天，还好我是一次过的，要是失败个两三次，那哭都没地方哭了，注意在管局审核这段时间，一定要保证ip地址是不能访问的哦！ 以上就是备案的基本流程了，现在说说我是怎么审核失败的，大家别踩我走过的这些坑哈！ 第一次备案初审没过，直接上图吧： 上面主要是说了三个问题： 1、主要联系手机号和应急联系手机号一样。 2、人脸识别失败(阿里云那边打电话说我做了一个鬼脸，黑人问号？我吃多了会在这种重要的场合做鬼脸呀！) 3、身份证地址不是福建省的，需要提供居住证或者暂住证 前面两个好处理，注意一下就能搞定，就是后面那个暂住证的问题真的难到我了，由于暂住证的办理非常麻烦并且备案省份不能修改，最后我还是放弃了这次备案。 第二次备案这次我换了省份，由于我的省份不在上面那六个省里面，上传资料这一步还是得乖乖拍幕布上传，但是，我的初审还是失败了，心酸！还是上图： 阿里云那边打电话过来说我的身份证有反光，我真是无语了，就那么一个小光点，有没挡住字，这样也不行，好在后来我重新拍照顺利通过了初审 这里不得不感叹阿里云的效率真的很快，一个小时就有了结果。初审通过了然后就是搞幕布的流程了，这是第二次审核，很幸运，这一次我一次就过了，上图： 后面的环节我也没什么可以说的了。初审通过后我好像得到了幸运女神的眷顾，审核都是一步通过，很多人在幕布环节都很容易挂，我有一个朋友在幕布里挂了3次，所以大家拍照的时候一定要仔细看要求哈，然后关于备案，阿里云有一个优惠，备多久送多久，这里我感觉阿里云还是比较有良心的，要是域名时间也送就好了(捂脸）！我的域名是ganmyds.cn，以后估计我的个人网站就用这个域名，到时候欢迎大家访问，最后在这里祝大家备案的时候都一次过，要是这篇文章对你有帮助的话就点个赞或者打赏一下哈!谢谢啦！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ps的一些经验]]></title>
    <url>%2Fps_start.html</url>
    <content type="text"><![CDATA[最近看百度贴吧ps吧笑出腹肌，很多人使用ps将照片变得非常有趣，感觉ps这个工具对于我们的日常生活有很大的作用，于是也开始学习ps的一些技巧，在这里记录一下。 ps下载安装ps全称是photoshop，网上有很多下载的地方，但是说实话，大多数都收费的，而且安装包巨大，我找了很多资源才找到破解版的，点击下载免安装版,密码是uznw 解压后打开，界面如下 将照片放到5寸白纸上改动图片大小我们先在网上随便下载一张证件照，按住ctrl+alt+i改变大小，这里说明一下： 一寸证件照长宽为： 2.54*3.62cm 两寸证件照长宽为：3.5*4.5cm 改动如下，改变红框里面的内容就可以了： 注意这里分辨率要改为300，不然照片会变得模糊 加上白边接下来我们给照片加上白边，按照ctrl+alt+c打开画布选项，改动如图： 现在你的照片就有白边了，效果如图 将照片放到5寸白纸上文件–&gt;新建，改动如图： 点击确定，出现了一张白纸，你之前的照片在红线部分那里 我们将鼠标放到红先部分直接拖到左侧，如图 选择移动工具，如图所示： 将我们的照片托动到白纸上，如图： 按住alt不动。开始拖动图片，如图我们就有了16张一寸照片了 照相馆里面的相片就是这么制作的，另外给大家说一个很有用的快捷键，撤销：ctrl+alt+z 侧面视角正面化我们去看画展的时候经常会拍照，但是有的时候在走廊只拍到侧面照，我们想将侧面照片转化为正面照片，就可以是用ps透视裁剪功能了，现在我们有一张画展走廊照片，如图 现在每一幅画都是侧面的，我们想看到某一幅画的正面，就可以使用ps的裁剪功能了，鼠标按住裁剪工具不动，选中透视裁剪工具，如图 选中你想查看的区域，可以先随便选一个区域然后自己慢慢调整，如图是我选择的区域 鼠标左键双击选中区域，我们就可以看到想要的效果了，如图]]></content>
      <categories>
        <category>photoshop</category>
      </categories>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo关于next主题的使用经验]]></title>
    <url>%2Fhexo_next.html</url>
    <content type="text"><![CDATA[ps: 之前用hexo写的博客一直有问题，首先是样式加载不到，我将hexo文件夹下的_config.yml里面的relative_link改为true之后就可以正常加载了，本来以为问题已经解决，但是替换next主题后陆陆续续各种路径找不到，索性就将hexo卸载重装，用了最新版本hexo后感觉世界都变得美好了，重新提交了blog，现在记录一下相关的配置。 hexo卸载重装卸载hexo，3.0.0之前版本执行 1npm uninstall hexo -g 3.0.0之后版本执行 1npm uninstall hexo-cli -g 查看hexo版本 1hexo -v 安装最新版hexo 1npm install hexo-cli -g ps：npm删除模块通用命令： 12npm uninstall xxx //删除模块npm uninstall -g xxx //全局删除模块 next主题安装下载next主题​ 进入你的博客下的themes文件夹下，目录结构类似Hexo\blog\themes，输入 1git clone https://github.com/iissnan/hexo-theme-next themes/next ​ 会下载一个next文件夹，如图所示 修改主题​ 找到Hexo\blog\\_config.yml(貌似别的博客都称这个文件为站点配置文件，下面我也怎么称呼吧！)，将theme原来的landscape改为next,如图 ​ 重启服务，在git里面输入 1hexo s 其他功能的添加配置语言​ 现在你的主题就成功改好了，但是还有一些小小的问题 ​ 我们找到Hexo\blog\themes\next_config.yml，搜索title，修改如下: 12345678# Sitetitle: 小小程序员subtitle: 记录学习过程中的点点滴滴description: 技术与生活，与我融为一体keywords: linuxauthor: 甘明阳language: zh-Hanstimezone: ​ 然后我们去Hexo\blog\themes\next\_config.yml，搜索scheme，如图： 这里有四种样式可以供我们选择，记住，有一个要去掉#，然后其他三个要加上# 添加头像​ 我们要加上自己的头像，在这个文件里搜索avatar，如图： ​ 将avatar的值改为我们自己的图片路径，如图 添加社交链接​ 还是在当前文件，搜索social，添加如下： 123456social: github: https://github.com/your-user-name twitter: https://twitter.com/your-user-name weibo: http://weibo.com/your-user-name douban: http://douban.com/people/your-user-name zhihu: http://www.zhihu.com/people/your-user-name ​ 内容可根据需求增减 添加背景音乐​ 使用hexo搭建的博客添加背景音乐非常简单，不同的主题改动稍微会有一点差别，以next主题为例，我们打开网易云随便搜索一首歌，以未闻花名为例，点击进去 点击生成外链播放器 选择不同的播放模式代码会不一样，想一进页面就播放音乐就选择自动播放，否则自动播放的对钩不要点，然后我们复制下面的代码 进入hexo/themes/next/layout/_macro,找到sidebar.swig,搜索links-of-blogroll，使用这个类的div是用来放置外链的，我们将复制的代码放到下面就可以了，如图： 然后，在git里面输入 1hexo g 1hexo s 现在打开localhost:4000就有效果了，如图 点击进入我的博客看看效果 添加字数统计功能​ 需要安装一个控件hexo-wordcount，在Hexo\blog\目录下安装，输入： 1npm install hexo-wordcount --save ​ 之前我在这一步遇到了一个报错，内容是 12345678910111213141516npm ERR! path C:\Users\home\Desktop\hexo_blog\blog\node_modules\minipass\node_mo dulesnpm ERR! code EPERMnpm ERR! errno -4048npm ERR! syscall scandirnpm ERR! Error: EPERM: operation not permitted, scandir 'C:\Users\home\Desktop\h exo_blog\blog\node_modules\minipass\node_modules'npm ERR! &#123; Error: EPERM: operation not permitted, scandir 'C:\Users\home\Deskto p\hexo_blog\blog\node_modules\minipass\node_modules'npm ERR! stack: 'Error: EPERM: operation not permitted, scandir \'C:\\Users\\h ome\\Desktop\\hexo_blog\\blog\\node_modules\\minipass\\node_modules\'',npm ERR! errno: -4048,npm ERR! code: 'EPERM',npm ERR! syscall: 'scandir',npm ERR! path: 'C:\\Users\\home\\Desktop\\hexo_blog\\blog\\node_modules\\minip ass\\node_modules' &#125;npm ERR!npm ERR! Please try running this command again as root/Administrator.npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\home\AppData\Roaming\npm-cache\_logs\2018-04-23T04_26_33_4 54Z-debug.log 在网上搜索了很多都没有看到有类似这个问题的，我感觉有可能是路径的问题，于是关掉本地服务器打算切换路径安装，结果有事忙忘了切换路径，居然成功安装了，原来原因是没有关掉本地服务器，囧！这里记录一下。 安装成功后，我们去主题配置文件里面搜索post_wordcount，改成如下配置 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 刷新一下，字数统计功能就有了，但是现在是没有单位的 到Hexo\blog\themes\next\layout\_macro\post.swig 路径下 搜索wordcount(post.content)和min2read(post.content)，修改如下 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;字&lt;/span&gt; 123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125;分钟&lt;/span&gt; 首页添加分页功能分页功能需要下载对应的插件，git切换到Hexo\blog\依次输入： 1npm install hexo-generator-index --save 1npm install hexo-generator-archive --save 1npm install hexo-generator-category --save 1npm install hexo-generator-tag --save 到站点配置文件里面，搜索index_generator，修改如下： 1234567891011121314#首页分页设置index_generator: path: '' per_page: 5 #这里是配置5篇文章一页 order_by: -date#归档页的分页设置archive_generator: per_page: 30 yearly: true monthly: true#标签页的分页设置tag_generator: per_page: 20 添加标题图片之前在网上看到很多人的博客都配置了标题图片，感觉这样挺好看的，于是也想搞一下，没想到在网上找了半天都搜不到答案，估计是我没有描述清楚问题，感觉描述能力也挺重要的，反正我费了老大的劲才找到答案，现在记录一下： 其实很简单，我们主要在每个md文件的前面加上photos配置信息就可以了，如下： 123456789---title: hexo关于next主题的使用经验date: 2018-04-17 10:42:00 tags: [hexo] categories: hexo description: 记录hexo博客各种功能的添加，包括国际化、头像、社交链接、背景音乐等11photos: - "http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg"--- 添加个性宠物个性宠物需要安装插件，切换到Hexo\blog\目录下，输入 1npm install -save hexo-helper-live2d 打开Hexo/blog/themes/next/layout,找到_layout.swig，,将下面代码放到&lt;/body&gt;之前： 1&#123;&#123; live2d() &#125;&#125; 然后在在 hexo 的 _config.yml中添加参数： 123live2d: model: wanko bottom: -30 然后hexo clean一下就行了 下面是所有宠物的名称，默认宠物是z16 Gantzert_Felixander Epsilon2.1 haru miku ni-j nico nito nipsilon nietzsche shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki width 宽度 默认值: 150，height 高度 默认值： 300，className &lt;canvas&gt;元素的类名 默认值： live2d， id &lt;canvas&gt; 元素的id 默认值： live2dcanvas，bottom &lt;canvas&gt; 元素的底部偏移 默认值： -20 如果嫌模型位置不正确 可以调整这个参数 ps：如果不想在手机上显示宠物，修改配置文件如下： 1234live2d: model: wanko bottom: -30 mobileShow: false 备案号的添加找到文件 1themes\next\layout\_partials\footer.swig 找到如下部分 12345678&lt;div class="copyright"&gt;&#123;##&#125;&#123;% set current = date(Date.now(), "YYYY") %&#125;&#123;##&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;##&#125;&lt;span itemprop="copyrightYear"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class="with-love"&gt; &lt;i class="fa fa-&#123;&#123; theme.footer.icon &#125;&#125;"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; theme.footer.copyright || config.author &#125;&#125;&lt;/span&gt; 改成 123&lt;div class="copyright"&gt;&#123;##&#125; &lt;span class="author" itemprop="copyrightHolder"&gt;浙公网安备 XXXX号&lt;/span&gt; seo优化一个博客不做seo优化是很难被百度爬虫爬取的，下面记录next主题的seo优化方面 网站自身优化减少无用链接的爬取，增加网站的权重，我们要给没用的链接添加rel=”external nofollow”的属性，让爬虫不爬取这个链接 找到文件： 1themes\next\layout\_partials\footer.swig 和文件 1themes\next\layout_macro\sidebar.swig 在所有a链接上加上rel=”external nofollow”的属性 首页title的优化找到文件： 1themes\next\layout\index.swig 将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改为 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 缩短链接长度hexo默认的链接格式是4级url，堆爬虫是非常不友好的，建议改一下，编辑站点_config.yml文件，，修改其中的permalink字段改为permalink: :title.html即可。 处理一些next的问题分类和标签按钮不能点击​ next目前没有分类和标签页面，需要我们手动添加，首先添加分类页面，在git命令行里面输入： 1hexo new page categories 完成后在source里面生成一个categories文件夹，我们进入Hexo\blog\source\categories，找到index.md，改动如下： 123title: categoriesdate: 2018-04-17 15:47:33type: "categories" 然后在git命令行里面输入: 1hexo g 刷新页面，分类按钮就能点击了。 然后添加标签页面，输入： 1hexo new page tag 进入Hexo\blog\source\tag，找到index.md,改动如下 123title: categoriesdate: 2018-04-17 15:47:33type: "tags" 剩下的步骤同上。 点击首页回不去 这个要看你的博客是不是处于子目录里面，例如我的博客路径为 1https://ganmyds.github.io/hexo_blog/ 就是有子目录,下面就是不含子目录 1https://ganmyds.github.io/ 如果你是将博客放在子目录里面，找到Hexo\blog\themes\next\_config.yml，搜索menu内容类似下面： 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 将内容改为你博客的对应链接就可以了，例如我的改动是： 123456789menu: home: https://ganmyds.github.io/hexo_blog/ # about: /about/ || user tags: https://ganmyds.github.io/hexo_blog/tags/ || tags categories: https://ganmyds.github.io/hexo_blog/categories/ || th archives: https://ganmyds.github.io/hexo_blog/archives/ || archive # schedule: schedule/ || calendar # sitemap: sitemap.xml || sitemap # commonweal: 404/ || heartbeat]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicate for Mysql的破解]]></title>
    <url>%2FNavicate_Mysql.html</url>
    <content type="text"><![CDATA[开发项目的时候经常会查询数据库的状态，每次都跑云服务器上查询感觉很麻烦，我现在郑重介绍一个好用的工具navicate，用过这个工具我真是爱上它啦，“这人用mysql不搭配navicate是不是傻”，工作中我经常会有这种想法，除了建表的便捷性，还可以设置各种查询彻底解放你的双手哦~ 下载安装首先这个工具需要我们的电脑上安装了mysql,如果你的电脑上没有安装mysql，点这里下载免安装版的：点击下载 密码是：o2mb 在D盘创建一个文件夹mysql,然后解压到这个文件夹，双击bin下面的mysqld.exe打开，如图 会有一个黑窗口一闪而过，我们不用管他，打开任务管理器看看是不是有一个mysqld.exe的进程在运行，如图： 如果有就说明你的mysql已经成功运行，接下来我们下载Navicate for Mysql和相关的破解文件，点击下载 密码：5t6d 下载找到navicat111_mysql_cs_x86.exe，双击安装，安装后找到安装的路径，会多一个文件夹Navicat for MySQL，然后我们把压缩包里面的PatchNavicat.exe复制到Navicat for MySQL下，如图 开始使用双击打开，选中navicte.exe，弹出一个success的框框就说明破解成功，然后我们双击navicte.exe打开，点击连接，如图： 选择mysql,输入如图，密码是root 建表首先建立数据库users： 建表，首先设置id为主键，点钥匙就可以取消主键 点击添加栏位添加新列 保存，写表的名字，注意公司都是以T_ 开头，复数结尾，比如T_students，前面不能有空格 修改表注意这里不能双击表名，要右键选择设计表，假如我想删除一列，右键这里点删除栏位 如果像查看表里面有哪些数据，直接双击表名就可以了 现在啥都没有，我们插入两条数据，点击加好可以添加一行新的 基本操作就这些，然后是关于mysql的存储引擎，最常用的是InnoDB和MyISAM，MyISAM效率较高，但是不支持事务，外键约束等属性，因此一般都用InnoDB，新版本默认使用InnoDB，建表的时候想要选择引擎点击选项，如图 建完表后想要查看引擎，对表右键选择对象信息 命令行使用切换到查询 点击新建查询 查询 增加数据 注意字符串要用单引号引起来，修改也可以 快捷查询点击保存，你的sql语句就保存下来了 以后想要查询所有数据，点击查询-&gt;查询所有数据-&gt;运行就可以啦]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧妙解决hexo博客使用的图片的处理]]></title>
    <url>%2Fhexo_img.html</url>
    <content type="text"><![CDATA[使用github和hexo搭建博客一段时间了，感觉图片的处理还真是挺麻烦的，有两个问题： 1、因为自己的博客经常要修改，会很频繁的使用hexo clean这个命令，经常会把图片清空，然后又要重新导入图片 要特别注意路径的处理，感觉挺浪费时间的 2、github提供的空间只有1g,图片会占用非常多的空间，对自己github未来的使用有负面影响 于是，根据这些问题，查阅了一些资料，找到了一个很好的处理方法，那就是使用在线链接，一般都是用图床放图片，但是大部分图床都是收费的，所以我没有选择图床，而是使用了另外一个工具，那就是github，我们可以申请一个github专门放自己的图片，然后所有博客都使用图片的在线地址即可，现在简单为初学者介绍具体步骤： (1)、申请一个github小号，步骤和你申请博客的github帐号一样，注意邮箱不能和博客帐号的邮箱一样，我们可以申请一个qq小号用于接受github邮件 (2)、新建一个仓库，我创建的是ganmyxh.io，考虑到以后有可能会在这个仓库里面放html就这样创建，你如果只是放图片这里可以随便取名，点击Create repository (3)、进入仓库，复制仓库路径，如图 (4)、在桌面上新建一个文件夹，github_img,右键打开git，输入命令git clone 加你的的地址 (5)、进入目录ganmyxh.io，新建文件夹img,如图 (6)、把图片放到img目录里面，在git里面输入 1cd ganmyxh.io/ 然后输入 1git add . 说明一下，git add 后面那个.表示将你要提交的所有文件放到暂存区里面，然后依次输入下面两个命令 1git commit -m "提交图片" 1git push 这里会要你输入自己的用户名和密码，如图 (7)、进入我们的github，随便点到一张图片里面，右键-&gt;复制图片地址。注意不能复制网页上面的地址， 以后我们自己的博客图片地址都可以这样使用，就不用担心地址的问题了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[erlang项目流程查看技巧]]></title>
    <url>%2Ferlang_01.html</url>
    <content type="text"><![CDATA[在公司用过erlang一段时间，主要是用erlang来加密传输数据的，现在把我关于erlang的一点感悟写出来，现在erlanng项目基本框架都是用rebar生成的，所以大部分erlang项目都用一些类似的特点。 一般都有几个基本的的文件夹，如图： 先说说相关文件夹的作用： 1、bin主要是存放数据库的，因为公司项目主要是做手机银行后台的，具体内容我不能说，我们主要使用的数据库是mnesia,用于存放项目的相关数据。 2、config文件夹是用来存放配置文件的，比方说连接的ip地址 3、include文件夹是用来存放头文件的 4、ebin文件夹主要是放beam文件的，beam文件是erlang编译后生成的文件 5、log是存放报文的，分析问题的时候经常会使用报文 6、script文件夹是存放脚步文件的 7、用得最多的是src文件夹，我们写的erlang代码一般是放在里面 然后说先erlang项目的入口，向java和c都有main入口，erlang也有自己的入口，是一个后缀名为.app的文件，还是以网上比较出名的erlang项目远古封神来看，是用sublime text3找到server.app，这里面可以提供很多项目的相关信息，如图： 主要看mod对应的值yg_server_app,然后我们搜索yg_server_app.erl，这是我们的启动模块 在这里面有一个函数start就是我们的入口，如图 这个模块引用了两个头文件，common.hrl和record.hrl,这两个文件主要是存放一些我们经常会使用的常量的，关于启动函数，其他不管，我们找到yg_server_sup和yg_server这两个模块，先看yg_server_sup，这个模块主要是启动启动一个监控，关于erlang监控，可以看我的另外一篇博客，然后是yg_server这个模块，如图 这里面就是启动各种服务的地方了，我们随便看一个，比如跟客户端相关的服务，start_client(),如图 这里面也是各种开启监控树。]]></content>
      <categories>
        <category>erlang</category>
      </categories>
      <tags>
        <tag>erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux上面安装配置mysql]]></title>
    <url>%2Flinux_mysql.html</url>
    <content type="text"><![CDATA[一个项目没有数据库可以说是无法想象的，作为一名开发人员，我们需要经常性的操作数据库。现在市面上有很多数据库可供我们使用，比如ACCESS，MSSQL，MYSQL，ORACLE，DB2,其中mysql可以说是目前最流行的数据库之一，mysql数据库主要有以下几个好处： 免费 跨平台 轻量级 支持多并发 mysql只有在linux运行环境下才能充分发挥其威力，在linux环境下搭建mysql就变得非常有意义了，下面我为大家详细介绍linux下mysql的搭建 下载mysql安装文件 有两个文件，分别是mysql-connector-java-5.1.6-bin.jar和mysql-standard-4.0.26-pc- linux-gnu-i686.tar.gz，点击下载 将两个安装文件拷贝到/home下,切换到root，输入命令： su root 不会从windows传文件到linux上？点这里传送 解压安装文件:1tar -zxvf mysql-standard-4.0.26-pc-linux-gnu-i686.tar.gz 解压缩后我们会得到一个目录如图 创建一个文件夹mysql :1mkdir mysql 移动文件到mysql里，输入命令:1mv mysql-standard-4.0.26-pc-linux-gnu-i686 mysql 创建一个组mysql注意这个命令要root权限才能使用，专门创建mysql组是为了方便以后管理mysql下面 的各个用户，输入命令: 1groupadd mysql 创建mysql用户放入mysql组，输入命令: 1useradd -g mysql mysql 进入mysql目录1cd mysql 初始化mysql数据库：1scripts/mysql_install_db --user=mysql 如图就是初始化成功： 修改权限 将mysql目录下所有文件以及子文件的所有者改为root、所在组改为mysql，输入命令： 1chown -R root:mysql . 注意后面有个点，表示使用当前路径，然后将数据文件夹用户改为mysql,输入命令： 1chown -R mysql data 我们检查一下是否成功改动，输入 1ls -l 结果如图所示： 后台运行mysql1bin/mysqld_safe --user=mysql &amp; 结果如图所示： 看看我们的mysql是否正常运行1netstat -anp | moe 看看3306端口是否存在，如图： 进入bin目录1cd bin 运行mysql1mysql -u root -p Enter password是要你输入密码，目前没有密码直接按enter即可，如图: ​ 现在mysql已经成功的安装到我们的linux下面了。到这里基本完成了，如果你想让以后的工作更方便，看看下面的内容。 现在我们打开mysql非常麻烦，需要进入/home/mysql/bin目录下执行，为了减少麻烦，我们可以将这个路径配置到环境变量里面，输入命令 1cd /root 1vi .bash_profile 改动如图 然后我们登出让配置文件生效，输入命令logout ，重新登录，现在你就可以在任意路径上运行mysql了。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux和windows之间传输文件]]></title>
    <url>%2Flinux_to_window.html</url>
    <content type="text"><![CDATA[​ 现在的开发流程一般都是在window上面写代码，然后在linux上面编译运行，但是windows和linux是不能直接传输文件的，下面我来详细的讲解linux与windows的传输，主要可以分为以下几步: 1、让window和linux互相ping通​ 首先确认我们的ip地址，在window上输入ipconfig，如图是我window上的ip地址 ​ ​ 然后在linux上输入ifconfig,如图所示 ​ ​ 这两个ip的网段不同，不能ping通，我们要改为一个网段，ip的前三个数字要相同，第四个数字不同，现在我将 ​ linux上的ip改为192.168.214.66，输入命令：ifconfig eth0 192.168.214.66，注意这个命令只能暂时改变ip， ​ 关闭linux就失效了。 ​ 现在我们重新ping就可以了，如图： ​ 2、关闭linux防火墙，输入命令：​ service iptables stop ​ 注意这个命令需要root权限，要先切换到root再使用，结果如图： ​ 3、如果你的系统是win7就要看这一步 ，不是的话可以直接跳过​ 在win7上我们要配置本地安全策略，在键盘上同时按win键和R键，win键就是ctrl和alt中间的那个键，输入 ​ secpol.msc ​ 如图： ​ ​ 找到本地策略-&gt;安全选项-&gt;网络安全：LAN管理器身份验证级别，把没有定义改为发送LM和NTLM-如果已协商，则使用NTLMV2会话安全，如图： 4、下载并安装SSH客户端，下载链接是：​ https://pan.baidu.com/s/173u4chFGQrgB3HJoTG1Cng ​ 密码是egc5 5、双击SshClient.exe打开，点击Quick connect，如图​ 6、填写参数Host Name是你的linux地址，User Name是你linux用户名，Port是对应的端口号，我们这里写22，如图： 接下来输入你root用户的密码即可 7、点击文件夹图标，如图： 8、现在你可以直接拖动文件到linux上了，如图 ​]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>

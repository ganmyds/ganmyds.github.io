<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hibernate里的HQL使用详解]]></title>
    <url>%2Fhibernate_hql.html</url>
    <content type="text"><![CDATA[HQL介绍HQL是Hibernate Query Language的简写，翻译成中文就是hibernate查询语言，是面向对象的查询语句，功能强大，由于实际需求的复杂性，对数据库的操作有很多条件，用原始的get()和load()远远满足不了需求，这个时候hibernate推出了功能强大的HQl语句，hql语句和sql语句不同，hql严格区分大小写，并且支持多态。 hibernate设计者建议数据库所有表都要有主键，而且最好是不要带业务逻辑的主键，原因： 1、很多情况下业务需求有可能改动，那么就面临要修改主键，对这条数据来说修改主键就面临数据不稳定的状态。 2、带有业务逻辑的数据有可能会重复，比如早期的身份证号，由于很多原因，出现了重复的现象。 例如我对查询student表里面所有属性 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; //举例说明hql语句使用 Session session = null; Transaction ts = null; try&#123; session = HibernateUtil.getCurrentSession(); ts = session.beginTransaction(); //检索所有学生信息 List&lt;Student&gt; list = session.createQuery("from Student").list(); //取出数据 for(Student s:list)&#123; System.out.println(s.getSname()); System.out.println(s.getSaddress()); &#125; System.out.println("***********************"); //使用Iterator迭代器取出数据 Iterator&lt;Student&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Student s = iterator.next(); System.out.println(s.getSname()); System.out.println(s.getSage()); &#125; ts.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(ts != null)&#123; ts.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session != null &amp;&amp; session.isOpen())&#123; session.close(); &#125; &#125; &#125; 这里最主要的语句就是List&lt;Student&gt; list = session.createQuery(&quot;from Student&quot;).list();这一句，由于在hibernate里面一张表对应一个类，我们的student表对应的类就是Student，hql语句面向对象的，是去查询这个类的属性而不是去查表的属性，直接’from student’就表示查询Student的所有属性，返回一个装满Student对象的集合，然后我们只需要对集合做操作就可以了，可以使用for循环增强也可以使用Iterator迭代器取出数据。两种方式上面都列举出来了。 在jdbc里面一般不要使用select * from 表名，但是这个规定在hibernate里面可以不遵循这个规则，如果遵循这个规则Hibernate的优势体现不出来，hibernate建议我们把整个对象的所有属性都查出来。 如果要查询部分信息，那么只需要将hql语句改动就可以了，例如我只想查询名字和所在系： 改成 1List list = session.createQuery("select sname, sdept from Student").list(); 但是由于我们只是查询一部分数据，不足以构成一个Student，所以不能用Student类的方法来取数据，使用以下方法取出数据 1234for(int i=0;i&lt;list.size();i++)&#123; Object[] objs = (Object[]) list.get(i); System.out.println("名字是：" + objs[0].toString() + ",所在系是：" + objs[1].toString());&#125; 这是因为数据不足以构成student对象，于是使用数组代替，这个list里面是像数据库一样两列多行数据，我们取出第一行数据，这个数据会放到一个数组里面，由于不知道数据的类型，就使用object对象指带，防止报错。当然，这种情况我们还得自己做二次封装，比较麻烦。不能发挥hibernate关联查询的特点。所以还是建议使用hibernate的所有查询语句，其实浪费的性能不多，因为实际上我们去查询都会带上各自条件，并且会带上分页，其实每一次查询出来的数据量一般不会特别多，我们甚至可以查出关联外键表的数据 1234567891011List&lt;Student&gt; list = session.createQuery("from Student").list();for(Student s:list)&#123; if(s.getStudcourses().size()==0)&#123; System.out.println(s.getSname()+"没有选课"); &#125;else&#123; Set&lt;Studcourse&gt; set= s.getStudcourses(); for(Studcourse sc: set)&#123; System.out.println(s.getSname()+"选了"+sc.getCourse().getCname()); &#125; &#125; &#125; hibernate真的是完全的面向对象编程 uniqueResult查询这是hibernate推出的一种查询方法，业务场景是用于查询数据只有一条的情况，因为假如我们使用get()或者load()查询，假如数据量有几百万在查询到的情况下还会接着往下查，uniqueResult查到了不会往下查，例如我们要根据某个id查询 1Student s = (Student) session.createQuery("from Student where sid = '20050003'").uniqueResult(); 如果查到了就返回一个对象，如果是查询全部属性就返回一个Student对象，如果是部分属性就返回一个object[]数组，没有查到会返回null，如果查询结果有多条会抛出异常，用户登录的场景建议使用这种查询 其他用法过滤重复数据使用distinct关键字，例如显示所有学生的性别和年龄 12345List list = session.createQuery("select distinct ssex, sage from Student").list();for(int i =0;i&lt;list.size();i++)&#123; Object[] o = (Object[]) list.get(i); System.out.println("性别是："+o[0]+",年龄是："+o[1]);&#125; 根据区间查询使用bewtween…and.. ，例如我想查询年龄在20岁和22岁之间所有学生的性别 12345List list = session.createQuery("select ssex, sage from Student where sage between 20 and 22").list();for(int i =0;i&lt;list.size();i++)&#123; Object[] o = (Object[]) list.get(i); System.out.println("性别是："+o[0]+",年龄是："+o[1]);&#125; 使用int和 not in来查询，例如我想查询所有年龄为20岁或者22岁的学生 1234List&lt;Student&gt; list = (List&lt;Student&gt;) session.createQuery("from Student where sage in (22,20)").list();for(Student s:list)&#123; System.out.println(s.getSname()+","+s.getSage());&#125; 分组层查询使用group by来查询，例如我想查询各个系的学生的年龄 1234List list = (List&lt;Student&gt;) session.createQuery("select sage from Student group by sdept").list();for(int i =0;i&lt;list.size();i++)&#123; System.out.println("年龄是："+list.get(i));&#125; 这里由于我查询的只有一个属性，不会返回object[]数组了，可以直接从list里面取出来 如果是查询各个系的平均年龄 1234List&lt;Object[]&gt; list = session.createQuery("select avg(sage),sdept from Student group by sdept").list();for(Object[] o:list)&#123; System.out.println("平均年龄是："+o[0]+"所在系是："+o[1]);&#125; 对分组后的数据再次查询使用having来查询，例如我想显示所有人数大于3的系 1234List&lt;Object[]&gt; list = session.createQuery("select sdept, count(*) from Student group by sdept having count(*)&gt;3").list();for(Object[] o:list)&#123; System.out.println(o[0]+"的人数是"+o[1]);&#125; 注意在hibernate里面having后面不能跟别名，要跟聚合函数，看了下sql语句，由于hibernate会把count(*)取一个自动的别名，我们取的别名没有生效，这种情况直接用别名去判断就报错找不到这个字段 查询女生人数少于200的系 1234List&lt;Object[]&gt; list = session.createQuery("select sdept, count(*) from Student where ssex='F' group by sdept having count(*)&lt;200").list();for(Object[] o:list)&#123; System.out.println(o[0]+"的女生人数是"+o[1]);&#125; 查询学生总分 1234List&lt;Long&gt; list = session.createQuery("select sum(grade) from Studcourse").list();for(Long o:list)&#123; System.out.println(o);&#125; 查询选修11号课程的最高分和最低分 1234List&lt;Object[]&gt; list = session.createQuery("select 11,max(grade),min(grade) from Studcourse where course.cid = 11").list();for(Object[] o:list)&#123; System.out.println(o[0]+"最高分是"+o[1]+"最低分是"+o[2]);&#125; 显示各科不及格的学生名字，科目和分数 1234List&lt;Object[]&gt; list = session.createQuery("select student.sname,course.cname,grade from Studcourse where grade &lt; 60").list();for(Object[] o:list)&#123; System.out.println("学生姓名是："+o[0]+"课程名字是："+o[1]+"分数是："+o[2]);&#125; 这里非常巧妙的用到了hibernate的面向对象思想，通过对象的属性获取，如果单纯使用数据库还是不太好处理的 这里是生成的sql语句，感觉写的挺好的 123456789101112select student1_.sname as col_0_0_, course2_.cname as col_1_0_, studcourse0_.grade as col_2_0_ from users.studcourse studcourse0_, users.student student1_, users.course course2_ where studcourse0_.sid=student1_.sid and studcourse0_.cid=course2_.cid and studcourse0_.grade&lt;60 统计各个科目不及格的学生的数量 1234List&lt;Object[]&gt; list = session.createQuery("select count(*),course.cname from Studcourse where grade &lt; 60 group by course.cname").list();for(Object[] o:list)&#123; System.out.println(o[1]+"有"+o[0]+"个学生不及格");&#125; 分页使用关键函数setFirstResult(index)和setMaxResults(index) 例如：按照学生年龄从小到大取出第一个到第三个学生 1234List&lt;Student&gt; list = session.createQuery("from Student order by sage asc").setFirstResult(0).setMaxResults(3).list();for(Student s:list)&#123; System.out.println(s.getSname()+"年龄是"+s.getSage());&#125; 注意setFirstResult的参数表示数据的下标，setMaxResults的参数表示后面几位，和limit的用法一样 封装成函数 12345678910111213141516171819202122232425262728293031323334353637//分页函数 private static void showResultByPage(int pageSize)&#123; Session session = null; Transaction ts = null; //总条数 int rowCount = 1; //当前页数 int pagenow = 1; //总页数 int pagecount = 1; try&#123; session = HibernateUtil.getCurrentSession(); ts = session.beginTransaction(); rowCount = Integer.parseInt(session.createQuery("select count(*) from Student").uniqueResult().toString()); pagecount = (rowCount-1)/pageSize+1; for(int i =0;i&lt;pagecount;i++)&#123; List&lt;Student&gt; list = session.createQuery("from Student order by sage asc").setFirstResult(i*pageSize).setMaxResults(pageSize).list(); System.out.println("*********************这是第"+(i+1)+"页"); for(Student s:list)&#123; System.out.println(s.getSname()+"年龄是"+s.getSage()); &#125; &#125; ts.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(ts != null)&#123; ts.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session != null &amp;&amp; session.isOpen())&#123; session.close(); &#125; &#125; &#125; 调用 1234public static void main(String[] args) &#123; showResultByPage(2); &#125; 这个分页方法还是非常方便的，不管什么数据库都可以使用，hibenate会转化成相应的sql语句 hibernate参数绑定使用关键函数，setParameter() ,使用参数绑定的好处： 1、可读性好 2、性能提高 3、防止sql注入漏洞 关于sql注入漏洞，举例说明： 我的数据库表： 使用sql语句查询 1SELECT * from student where sid = 20050005 and sdept=&apos;生物系&apos; 可以查到数据 改一下： 1SELECT * from student where sid = 20050005 and sdept=&apos;生物系111&apos; 查不到数据 再改一下 1SELECT * from student where sid = 20050005 and sdept=&apos;生物系111&apos; or 1=&apos;1&apos;; 所有的数据都出来了 实际上这是因为where执行的语句可以返回一个boolean，当这个boolean的值为true的时候，会查出所有数据，当这个boolean的值为false的时候，就什么都查不到，例如我们直接使用true来查，看结果 所谓的sql注入漏洞其实就是通过or语句来返回一个true，达到获取用户所有数据的目的 参数绑定有两种形式： 1、使用:字段名 1List&lt;Student&gt; list = session.createQuery("from Student where sdept=:a1 and sage&gt;:sage").setString("a1", "计算机系").setString("sage", "2").list(); 注意 “:” 后面的字符串可以随便取名，但是一般和字段名保持一致，后面的setString不能用位置做第一个参数 2、使用?占位符 1List&lt;Student&gt; list = session.createQuery("from Student where sdept=? and sage&gt;?").setString(0, "计算机系").setString(1, "2").list(); 这样使用?占位符后面的setString才能用位置做第一个参数，然后参数是从0开始编号的 另外query是可以分开写的，不是一定要连起来写 1234Query query = session.createQuery("from Student where sdept=? and sage&gt;?");query.setString(0, "计算机系");query.setString(1, "2");List&lt;Student&gt; list = query.list(); 由此我们可以引申，使用for循环注入，将方法封装起来 1234567891011121314151617181920212223//提供一个统一的查询方法，hql形式，使用?的方式,由于openSession在查询的时候不需要使用事务提交，就不用openSession public static List excuteQuery(String hql,String[]parameters)&#123; List list = null; Session s = null; try&#123; s = OpenSession(); Query query = s.createQuery(hql); if(parameters !=null &amp;&amp; parameters.length&gt;0)&#123; for(int i=0;i&lt;parameters.length;i++)&#123; query.setString(i, parameters[i]); &#125; &#125; list = query.list(); &#125;catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(s!=null&amp;&amp;s.isOpen())&#123; s.close(); &#125; &#125; return list; &#125; 关于静态的使用，代码块本身是可以静态的，但是session要保证每次都是一个新的，不是当前的那个，防止阻塞的问题 关于调用 12345678public static void main(String[] args) &#123; String hql = "from Student where sdept=? and sage&gt;?"; String[] parameters = &#123;"计算机系","2"&#125;; List&lt;Student&gt; list = HibernateUtil.excuteQuery(hql, parameters); for(Student s:list)&#123; System.out.println("学生姓名是" + s.getSname() + ",学生年龄是"+s.getSage()); &#125;&#125; 将以上代码功能完善，添加分页功能 12345678910111213141516171819202122232425//提供一个统一的分页查询 public static List excuteQueryByPage(String hql,String[]parameters,int pagenow,int pagesize)&#123; List list = null; Session s = null; try&#123; s = OpenSession(); Query query = s.createQuery(hql); if(parameters !=null &amp;&amp; parameters.length&gt;0)&#123; for(int i=0;i&lt;parameters.length;i++)&#123; query.setString(i, parameters[i]); &#125; &#125; query.setFirstResult((pagenow-1)*pagesize).setMaxResults(pagesize); list = query.list(); &#125;catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(s!=null&amp;&amp;s.isOpen())&#123; s.close(); &#125; &#125; return list; &#125; 这个时候main方法调用 12345678910public static void main(String[] args) &#123; String hql = "from Student where sdept=? and sage &gt; ?"; String[] parameters = &#123;"计算机系","2"&#125;; int pagenow = 1; int pagesize = 5; List&lt;Student&gt; list = HibernateUtil.excuteQueryByPage(hql, parameters, pagenow, pagesize); for(Student s:list)&#123; System.out.println("学生姓名是" + s.getSname() + ",学生年龄是"+s.getSage()); &#125; &#125; 然后是统一的添加方法 1234567891011121314151617181920public static void excuteAdd(Object obj)&#123; Session session = null; Transaction tx = null; try&#123; session = OpenSession(); tx = session.beginTransaction(); session.save(obj); tx.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(tx!=null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session!=null&amp;&amp;session.isOpen())&#123; session.close(); &#125; &#125; &#125; 统一的修改和删除方法 1234567891011121314151617181920212223242526public static void excuteUpdate(String hql,String[] parameters)&#123; Session s = null; Transaction tx = null; try&#123; s = OpenSession(); tx = s.beginTransaction(); Query query = s.createQuery(hql); if(parameters !=null &amp;&amp; parameters.length&gt;0)&#123; for(int i=0;i&lt;parameters.length;i++)&#123; query.setString(i, parameters[i]); &#125; &#125; query.executeUpdate(); tx.commit(); &#125;catch (Exception e) &#123; e.printStackTrace(); if(tx!=null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(s!=null&amp;&amp;s.isOpen())&#123; s.close(); &#125; &#125; &#125; 使用子查询例如查询所有选课为21号的学生的信息 有两个方法，一、获取Studcourse对象，根据Studcourse获取Student对象 123456String hql = "from Studcourse where course.cid=21"; String[] parameters = null; List&lt;Studcourse&gt; list = HibernateUtil.excuteQuery(hql, parameters); for(Studcourse o:list)&#123; System.out.println(o.getGrade()+o.getStudent().getSname()); &#125; 这里有一个懒加载的问题，会报错 1Exception in thread "main" org.hibernate.LazyInitializationException: could not initialize proxy - no Session 这是由于我们获取的Student对象是一个代理对象(proxy)，由于session已经关闭，到数据库查询会报错 对Student.hbm.xml设置禁用懒加载，添加属性laze=”false”就可以了，但是这种方式会多次连接数据库，for循环有几次就会去数据库查几次，效率很低下 方法二、通过面向对象取出来 123456String hql = "select student.sname,student.sid from Studcourse where course.cid=21"; String[] parameters = null; List&lt;Object[]&gt; list = HibernateUtil.excuteQuery(hql, parameters); for(Object[] o:list)&#123; System.out.println(o[0]+","+o[1]); &#125; 这种方法的缺点是hql语句过长 critiria使用critiria是一种更加面向对象的查询，例如查询年龄大于10岁的学生 1234567891011121314151617181920212223242526public static void main(String[] args) &#123; Session session = null; Transaction tx = null; try&#123; session = HibernateUtil.OpenSession(); tx = session.beginTransaction(); Criteria cri = session.createCriteria(Student.class); //添加条件,这里Restrictions.gt()里面的gt表示大于，ge表示大于等于，lt小于，le小于等于 cri.add(Restrictions.gt("sage", new Integer(10))); List&lt;Student&gt; list = cri.list(); for(Student s:list)&#123; System.out.println(s.getSname()); &#125; tx.commit(); &#125;catch (Exception e) &#123; if(tx!=null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session!=null&amp;&amp;session.isOpen())&#123; session.close(); &#125; &#125; &#125; 使用模糊查询 例如：查出所有成姓学生 123456String hql = "from Student where sname like ?"; String[] parameters = &#123;"成%"&#125;; List&lt;Student&gt; list= HibernateUtil.excuteQuery(hql, parameters); for(Student s:list)&#123; System.out.println(s.getSname()); &#125; 创建数据库如果我们要创建出对应的数据库，需要配置hibernate.cfg.xml，添加配置信息 1&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt; 这个标签里面有四种类型的值： 1、create，当我们的应用程序加载hibernate.cfg.xml的时候(new configuration().config())就会根据映射文件创建出数据库，每次都会创建，如果原先有表会先删掉再创建 在*.hbm.xml里面的class标签设置生成表的数据库名和表名，然后在hibernate.cfg.xml文件里面添加 1&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt; 主要是这种创建方式会删掉原来表中的数据 2、update，如果数据库中没有该表，则创建，如果有该表，则看有没有变化，如果有变化，则更新，反正不会删掉表里面的数据 例如我将映射的表字段sdept改为sdept1，字段最大长度从30改为20，那么在表里面就会生成一个新的字段sdept1，长度为20，原先的sdept字段和里面的数据还是保留 3、create-drop，在显示关闭sessionFactory的时候，会drop数据库的schema，我们调用sessionFactory创建session用完sessionFactory也会关闭，但是不是显示关闭，必须要我们调用sessionFactory.close()方法才行，尽量不要使用create-drop 4、validate，每次添加数据的时候会验证数据库的表结构和hbm的结构是否一致，用的很少 在开发测试的过程中，我们配那个都可以，但是如果上了生产，这个选项最好就删掉，要配置也最好配置update，或者配置一次让数据库表生成，然后还是要删掉 关于domain对象注意： 1、一定要配置默认的构造方法，用于hibernate反射该对象 2、要配置一个没有业务意义的主键 3、给每个属性提供一个get和set方法，原则上一个属性对应数据库表里面的一个字段，或者对应一个对象，如果domian里面有一个字段，我们没有配置到数据库是没有什么关系的，最多只是这个字段不会生成，但是如果我们配置的字段在domain里面没有，就会报错的，因为这个配置会使用domain的反射机制 4、属性一般是private的访问权限 关于可选项在*.hbm.xml文件里面，table属性可以不写，如果不写就默认使用配置的对象第一个字母小写生成 type也可以不配置，如果没有写，就会根据domain对象对应的属性 hibernate对象三种状态在hibernate里面将对象分为三种状态，分别是瞬时(transient)、持久(persistent)、脱管(detached)状态 当一个对象刚被创建还没有处于session的管理之下且在数据库中没有记录的时候，是处于瞬时态的(表示状态不稳定，随时都有可能消失)，然后我们调用session.save()保存这个对象的时候，它就变成了持久态了，然后当session关闭后，这个对象就脱离了session的管理，状态就变成了脱管态(也叫游离态) 当处于瞬时态的时候改变数据，是不会反映的数据库中，当处于持久态的时候，只要使用set()就会反映的数据库中，脱管状态如果要修改是不会反映的数据库中，例如以下这个例子： 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; Course course = new Course(61, "php"); //这个时候course既没有处于session管理，也没有在数据库中有数据，是处于瞬时态的，修改不会反映到数据库中 course.setCcredit(5); Session session = null; Transaction tx = null; try&#123; session = HibernateUtil.getCurrentSession(); tx = session.beginTransaction(); //使用了save这个对象的这一瞬间，这个对象就处于持久态 session.save(course); //由于course是处于持久态，我们改变course的cname会反映到数据库中，hibernate产生一条update语句 //hibernate会优化代码。我们的两个改动在hibernate里面只生成一条update语句 course.setCname("php1"); course.setCcredit(6); //如果在这里调用session.delete(course),首先会去数据库删掉数据，那么在session关闭后就又变为瞬时态 //并且处于持久态后只会生成一条delete语句，不会产生upodate语句啦 tx.commit(); &#125;catch (Exception e) &#123; if(tx != null)&#123; tx.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; if(session!=null&amp;&amp;session.isOpen())&#123; //session关闭这一瞬间，course就处于脱管态 session.close(); //由于course处于脱管态，我们设置php2这个动作不会反映到数据库中 course.setCname("php2"); &#125; &#125; &#125; 完整图解，这里说明一下，使用session的get()、load()、find()、iterate()、etc都会进入持久态，并且不管是openSession还是getCurrentSession()，在commit()后都不是持久态了 hibernate映射关系1、one-to-one，例如身份证和人之间的关系 2、one-to-many，例如部门和员工，一个部门可以有多个员工 3、many-to-one，例如员工和部门，多个员工对应一个部门 4、many-to-many，例如学生和老师，一般在编程中要尽量避免这种关系，如果出现了many-to-many，一般转换成两个one-to-many或者many-to-one，这个程序就好控制，同时不会有冗余，例如我们上面的表已经分解了这种关系，hql语句在多表查询有很多优势 在hibernate里面，外键会映射成一个对象]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate框架配置详解]]></title>
    <url>%2FHibernate_sum.html</url>
    <content type="text"><![CDATA[hibernate主要封装java里面jdbc这部分，是jdbc代码的轻量级的对象封装，使用hibernate有很多好处： 1、降低了代码的耦合性，程序员只需要专注业务代码即可 2、换了数据库只需要改动配置文件即可 3、大大提高程序员的开发效率 4、支持分布式架构 hibernate核心思想是ORM(object relation mapping)，官方推荐先写domain层，再写配置文件，最后生成数据库，但是实际上都是先设计好数据库，然后写配置文件，最后再写domain层，这里也是按照实际顺序配的 数据库代码(使用的是mysql数据库，以employee为例): 1234567CREATE TABLE `employee` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL, `email` varchar(64) NOT NULL, `hiredate` date NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 我们在这张表里面设计了4列，分别是主键id（int类型），name（varchar类型），email（varchar类型），hiredate（date类型），那么我们的domain类的结构也要设计成一样 1234567891011121314151617181920212223242526272829303132333435package com.ganmy.doman;//这个pojo对象应当按照规范序列号，目的是可以唯一标识该对象,同时可以在网络和文件上传输public class Employee implements java.io.Serializable&#123; //添加序列版本号 private static final long serialVersionUID = 1L; private Integer id; private String name; private String email; private java.util.Date hiredate; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public java.util.Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(java.util.Date hiredate) &#123; this.hiredate = hiredate; &#125; 接下来是hibernate与数据库的连接配置文件hibernate.cfg.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 配置使用的Driver --&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 连接数据库的，设置编码为utf-8 --&gt; &lt;property name="connection.url"&gt; &lt;![CDATA[jdbc:mysql://localhost:3306/users?useUnicode=true&amp;characterEncoding=utf8]]&gt; &lt;/property&gt; &lt;!-- 用户名 --&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;!-- 密码 --&gt; &lt;property name="connection.password"&gt;root&lt;/property&gt; &lt;!-- 配置dialect 方言 告诉hibernate使用的mysql数据库--&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 显示出对应的sql语句 --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- 优化sql语句格式，会自动换行，方便程序员阅读 --&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;!--create表示mysql如果没有该表则创建，如果有就先删掉再创建,update如果表结构没有改变则会不会删表 就是没有添加新记录就不会创建--&gt; &lt;!--&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;--&gt; &lt;!-- 加载关系对象映射文件 com/ganmy/doman/指的是这个文件所在的包--&gt; &lt;mapping resource="com/ganmy/doman/Employee.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 然后是对象关系映射文件，mvc模型的设计理念是一张表对应一个类，表里面一行对应一个对象，hibernate也是这样设计的，实现对象与数据库表的映射关系的核心文件是类名.hbm.xml，一般这个类名和表名一样，只是首字母大写，我们的表名是employee，那么对应的文件就是Employee.hbm.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--该文件要清楚地表述出 类 和 表 的对应关系--&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping package="com.ganmy.doman"&gt; &lt;class name="Employee" table="employee"&gt; &lt;!-- id元素用于指定主键属性 --&gt; &lt;id name="id" column="id" type="java.lang.Integer"&gt; &lt;!-- generator用于指定主键值生成的策略 使用increment自增长策略--&gt; &lt;generator class="increment"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 除了主键的其他属性 property里面的name表示类的属性名，type表示这个属性的类型 ， column里面的name表示表对应的一列，一般设计的时候数据库的结构和类的属性设计一样--&gt; &lt;property name="name" type="java.lang.String"&gt; &lt;column name="name" not-null="false" /&gt; &lt;/property&gt; &lt;property name="email" type="java.lang.String"&gt; &lt;column name="email" not-null="false" /&gt; &lt;/property&gt; &lt;property name="hiredate" type="java.util.Date"&gt; &lt;column name="hiredate" not-null="false" /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 最后是我们的调用，主要是main方法的代码： 123456789101112131415161718192021public static void main(String[] args) &#123; //将configuration configuration主要用来读取配置文件 默认找hibernate.cfg.xml文件 完成初始化 Configuration configuration = new Configuration().configure(); //创建sessionfactory 是一个重量级的接口 SessionFactory sessionFactory = configuration.buildSessionFactory(); //创建一个和数据库的会话 Session session = sessionFactory.openSession(); //对于hibernate而言，做增删改的时候要使用事务提交 Transaction transaction = session.beginTransaction(); //创建一个雇员对象 Employee employee = new Employee(); employee.setName("zhangsan"); employee.setEmail("1556254@123.com"); employee.setHiredate(new Date()); //保存 session.save(employee); //提交事务 transaction.commit(); session.clear();&#125; 这里说明一下： 1、sessionFactory是一个重量级的接口，会占用很多内存，我们要保证一个数据库只对应一个sessionFactory 2、session指的是代码和数据库之间的会话，不是我们javaweb里面的session 3、hibernate设计者设计在对表进行增删改操作的时候要使用事务提交，如果不使用事务提交将无法生效，也不报错，下面是具体的优化，由于sessionFactory是一个重量级的接口，会占用很多内存，我们要保证一个数据库只对应一个sessionFactory，使用静态代码块和单例模式来加载sessionFactory的创建，将sessionFactory封装到一个类里面 123456789101112131415final public class MySessionFactory &#123; //一个sessionFactory对应一个数据库，sessionFactory是一个接口 private static SessionFactory sessionFactory=null; private MySessionFactory()&#123;&#125;; static&#123; sessionFactory = new Configuration().configure().buildSessionFactory(); &#125; public static SessionFactory getSessionFactory()&#123; return sessionFactory; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637 /** * @param args */public static void main(String[] args) &#123; updateEmployee_roll();&#125; /** * 使用回滚的事务提交 */private static void updateEmployee_roll() &#123; //修改用户 //获取会话 Session session = MySessionFactory.getSessionFactory().openSession(); Transaction ts = null; try&#123; ts = session.beginTransaction(); //获取要修改的用户，然后修改,可以通过主键属性获取该对象实例，和表的记录对应 Employee emp=(Employee)session.load(Employee.class, 2); emp.setName("甘明阳11"); emp.setEmail("123@11"); int i = 9/0; ts.commit(); session.close(); &#125;catch(Exception e)&#123; if(ts != null)&#123; ts.rollback(); &#125; throw new RuntimeException(e.getMessage()); &#125;finally&#123; //关闭session if(session!=null&amp;&amp;session.isOpen())&#123; session.close(); &#125; &#125;&#125; 使用事务模版写最安全，即使报错不会提交到数据库，可以保证数据的完整性，而且能快速定位到错误。 session的获取session的获取方式有两种，分别是openSession()和getCurrentSession()，特点： 1、openSession()是获取一个新的session 2、getCurrentSession()获取和当前线程绑定的线程，换言之，在同一个线程中，我们获取的session是同一个session，这样可以利于事务的控制 3、如果希望使用getCurrentSession()，需要配置hibernate.cfg.xml，添加： 12//thread代表session可以和当前线程绑定&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; 根据实际应用选择使用那个session，如果在同一个线程中，保证要使用同一个session就使用getCurrentSession()，如果在一个线程中要使用不同的session就使用openSession() 4、通过getCurrentSession()获取的session在事务提交以后会自动关闭，通过openSession()获取的session必须手动关闭 5、如果是通过getCurrentSession()获取的session在进行查询的时候也要以事务的方式提交，而且在commit以后，对象获取属性会报错could not initialize proxy - no Session，要在commit之前获取属性 全局事务和本地事务假如我们使用的数据库只有一个，那么控制这个数据库的事务就是本地事务，假如我们连接多个数据库，比如银行的转账系统，从工行转账到农行，那么控制这个跨数据库的事务就被成为全局事务(jta)，全局事务的价值更高 session获取对象的两种方法session获取对象的两种方法分别是get()和load()，他们的区别是： 1、查询没有的数据返回不同，例如一个表只有10行数据，我们去第100行的数据，那么使用get()会返回null，而使用load()会报错ObjectNotFoundExpcetion 2、使用get查询数据会先到session缓存去查然后去二级缓存去查，如果没有立即向数据库发出sql语句，查询到了不会发sql语句。 使用load()去查询，也是先到session缓存去查然后去二级缓存去查，如果没有找到就返回一个代理对象，不会立即向数据库去查，等到后面使用这个代理对象操作的时候，才到DB中去查，这个现象我们称为lazy load(懒加载)，如果用户后来真的要用到这个对象，那么load()回到数据库去查，然后把查询的的结果存放到二级缓存里面，下一次再用这个sql语句去查询还是按照一级缓存、二级缓存的顺序去找，这个时候二级缓存已经有这个数据就不会到数据库去查了，如果二级缓存的命中率很高就会将这个结果放到一级缓存里面。 3、通过修改配置文件可以取消懒加载，在*.hbm.xml里面的class标签添加一个属性laze=”false”就行了 4、如果确定数据库一定有这个对象就使用load()，效率比较高，如果不确定就使用get()，防止报错 一级缓存和二级缓存一级缓存就是sessionfactory的缓存，又叫session级缓存，二级缓存是介于文件和内存之间的缓存，一级缓存不需要配置就可以用，二级缓存需要配置启用才能用，缓存的机制可以减少对数据库的频繁访问，由于hibernate的缓存机制实现的很好，使用hibernate可以优化对数据库查询的次数 线程局部变量模式一般我们的变量范围是一个函数域，但是其实变量是可以和一个线程绑定的，这就是线程局部变量模式，还是以session为例 12345678910111213141516171819202122232425262728293031323334package com.ganmy.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtil &#123; private static SessionFactory sessionFactory = null; //threadLocal是本地线程 private static ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;(); //将构造方法私有化 private HibernateUtil()&#123;&#125;; static&#123; sessionFactory = new Configuration().configure().buildSessionFactory(); &#125; //获取全新的session public static Session OpenSession()&#123; return sessionFactory.openSession(); &#125; //获取与当前线程绑定的session public static Session getCurrentSession()&#123; Session session = threadLocal.get(); if(session == null)&#123; session = sessionFactory.openSession(); threadLocal.set(session); &#125; return session; &#125; &#125; 将session放到本地线程threadLocal里面，以后可以直接从threadLocal获取，这样写就不需要配置thread了。 Query接口在hibernate里面的查询使用hql语句，使用hibernate我们只需要写hql语句查询，不需要分数据库，因为hibernate会根据不同的数据库将hql语句翻译成对应的sql语句，例如： 12345678910111213141516171819public static void main(String[] args) &#123; Session session = HibernateUtil.getCurrentSession(); Transaction ts = null; try&#123; ts = session.beginTransaction(); //使用hql语句查询，Employee表示对应的domain对象，id表示domain里面的id属性，不是数据库表里面的列名称 //where后面的条件可以是类的属性名，也可以是表的字段，最好使用类的属性名称 Query query = session.createQuery("from Employee where id = 100"); //通过list方法获取结果，这个list会自动通过反射机制封装成对应的domain对象，不需要进行二次封装 List&lt;Employee&gt; list = query.list(); for(Employee e:list)&#123; System.out.println(e.getName()+e.getEmail()); &#125; &#125;catch(Exception e)&#123; if(ts != null)&#123; ts.rollback(); &#125; &#125; &#125; 使用逆向工程生成配置文件一、使用数据库浏览器连接数据库 1、创建数据库表 2、创建java项目 3、通过myeclipse的数据库浏览器连接到mysql数据库 打开数据库浏览器 -&gt;windows -&gt; open persective -&gt; Myeclipse Database Explorer-&gt;在DB Brower点击右键-&gt; 选择new，创建数据库浏览器连接，然后再到项目，右键 -&gt;myeclipse -&gt; Add Hibernate Annotations 点击Test Driver弹框success表示连接成功 然后在打开右边的项目，找到table，右键，Edit data就可以了 注意mysql5.6的版本不能用5.0的jar包连接，会报错，要用支持5.6的jar包需要使用5.1.25版本的驱动，而且貌似数据库浏览器好像有缓存的样子，我换了一个高版本的jar包还是报错，然后我以为是jar版本不对，陆陆续续在网上找了很多版本的jar包，但是无一例外全部报错，我真的被搞的头都大了，搞了一天没找到原因，后来我思路一转，是不是数据库的问题不是jar包的问题呢，连接我云服务器的mysql，结果可以，然后再连接本地的mysql也都可以了，真的是一脸懵逼的解决了问题。 二、引入hibernate开发包 项目右键-&gt;myeclipse-&gt;add hibernate capabilities，按照如图所示填写 点击Next 点击Next 点击Next 如果希望把hibernate开发包升级，我们可以重新引入包，到文件路径把自动引入的jar包删掉，然后将我们自己的jar包引入 然后我们到数据库浏览器这一边，右键点击表，选择hibernate reverse engineering 点击browse选择包，将domian对象所在的包引入，下一步 、 下一步 然后下一步下一步点finally就可以了 最后：感觉hibernate真的大大提高了程序员的效率，不用写jdbc代码了，是一个值得学习的框架]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jquery做图形单选框]]></title>
    <url>%2Fradio_sum.html</url>
    <content type="text"><![CDATA[今天看了一下开源中国的注册页面，发现他们的性别选择做的很好看，不是使用原生单选框而是使用图片做的，如图： 作为对界面要求高的人，怎么能忍受自己的注册页面还使用原生的单选框呢？ 我开始思考怎么做出这种效果，首先是图片的问题，这个使用截图工具截下来，一共4个图片，然后是显示逻辑，这个使用jquery控制显示和隐藏，改变display的值就可以了，样式实现很简单，然后就是传值的问题，怎么让servlet知道用户的选择呢，有两个方案 1、在js里面设置一个页面变量，sexChecked，值为1表示选中男士，值为2表示选中女士，然后在提交的时候把sexChecked传给servlet就可以了。 2、在html里面写一个隐藏的单选框，用户选中男士的时候让id为manRadio的单选框变为选中状态，选中女生的时候让id为 womanRadio的单选框变为选择状态 由于我是使用form表单提交不是使用ajax提交数据的，form表单提交的时候数据没有经过js这一块，感觉不太好改，还是第二个方案比较简单，不需要改动form表单的参数，我选择第二个方案，代码如下 html代码： 1234567891011121314151617181920&lt;div class="form-group padding_tb5"&gt; &lt;div class="inlineBlock" id="man"&gt; &lt;img src="img/default/man.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;男士&lt;/span&gt; &lt;/div&gt; &lt;div class="inlineBlock hider" id="manHide" onclick="checkSex('1')"&gt; &lt;img src="img/default/noselect.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;男士&lt;/span&gt; &lt;/div&gt; &lt;div class="womanDiv hider" id="woman"&gt; &lt;img src="img/default/woman.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;女士&lt;/span&gt; &lt;/div&gt; &lt;div class="womanDiv margin_l25" id="womanHide" onclick="checkSex('2')"&gt; &lt;img src="img/default/wonoselect.png" class="vertical_mid"&gt; &lt;span class="sex_text"&gt;女士&lt;/span&gt; &lt;/div&gt; &lt;input type="radio" name="sex" value="1" id="manRadio" checked="checked"&gt; &lt;input type="radio" name="sex" value="2" id="womanRadio"&gt;&lt;/div&gt; js代码： 12345678910111213141516//性别选择判断function checkSex(id)&#123; if(id=="1")&#123; $("#manHide").css("display","none"); $("#man").css("display","inline-block"); $("#womanHide").css("display","inline-block"); $("#woman").css("display","none"); $("#manRadio").attr("checked","checked"); &#125;else if(id=="2")&#123; $("#womanHide").css("display","none"); $("#man").css("display","none"); $("#woman").css("display","inline-block"); $("#manHide").css("display","inline-block"); $("#womanRadio").attr("checked","checked"); &#125;&#125; 这里出现了一个很神奇的问题，这个单选框居然只能改动一次，一开始我以为是没有进入if判断，使用console.log()打印却能打印出来，jquery里面的id也没有写错，代码看起来完全没有问题，这下我有点懵逼了，在网上找来找去也没有找到类型的问题，难道是不能给checked的值使用checked吗？我改成了false和ture，还是一样只能改动一次，几个假设都被推翻，确实很头疼，这个时候我想了一下，为什么第一次可以改动，肯定是这两个radio有什么不一样的地方，好像第一个radio一开始是checked的状态的，我把这个属性去掉了，再测试可以改动两次了，果然radio的checked会影响jquery的改动，改变下一个radio的时候去掉上一个radio的checked属性不就可以了吗，我加了一句remove的代码，果然可以改动啦，html还有这么神奇的地方真是的，改动如下 1234567891011121314151617181920//性别选择判断function checkSex(id)&#123; if(id=="1")&#123; $("#manHide").css("display","none"); $("#man").css("display","inline-block"); $("#womanHide").css("display","inline-block"); $("#woman").css("display","none"); //改变下一个radio的时候要移除已经选中的radio $("#womanRadio").removeAttr("checked"); $("#manRadio").attr("checked","checked"); &#125;else if(id=="2")&#123; $("#womanHide").css("display","none"); $("#man").css("display","none"); $("#woman").css("display","inline-block"); $("#manHide").css("display","inline-block"); //改变下一个radio的时候要移除已经选中的radio $("#manRadio").removeAttr("checked"); $("#womanRadio").attr("checked","checked"); &#125;&#125; 这样改动就可以了，功能成功实现，效果如下： 总结：平时做项目的时候要多思考，遇到问题仔细分析，多看看别人的技术博客，这样才能进步得更快。页面跳转传送门]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>radio</tag>
        <tag>checked</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js函数深入研究]]></title>
    <url>%2Fjavascript_start.html</url>
    <content type="text"><![CDATA[javascript入门容易精通难，由于语法比较松散，很多用法需要我们自己去研究，这段时间我主要是研究js函数的使用 使用函数作为参数在js里面函数也是一种数据类型，我们可以使用函数作为另外一个函数的参数，例如： 123456789101112//定于被调用的函数function hello()&#123; for(var i=0;i&lt;5;i++)&#123; console.log(i); &#125;&#125;//定义去调用的函数function go(fn)&#123; window[fn].call(this);&#125;//调用，这里直接写hello就可以啦，后面不用小括号哦go(&quot;hello&quot;); 使用函数(带参)作为参数感觉上述方法在实际效果中并不好用，因为实际情况一般都有参数，下面来介绍一个带参数函数的使用 1234567891011//定义主动调用函数function test1(value,Func)&#123; Func(value)&#125;//定义被调用函数function test3(data)&#123; alert(data);&#125;//去调用test1(&apos;22&apos;,test3); 在test1里面有两个参数，被调用函数的参数，和调用函数， ajax封装将上面的知识引申到实际代码里面，比如说ajax方法的封装 下面是一个ajax的基本使用： 123456789101112131415161718$.ajax(&#123; //这是请求的servlet url: &quot;hqyzm&quot;, //这里定义请求类型 method: &quot;post&quot;, //这里是前端要传给后台的数据 data: &#123; phone: &quot;12345678912&quot; &#125;, //这里是请求成功调用的方法 success: function(data)&#123; console.log(data) &#125;, //这里是请求失败调用的方法 error: function(data)&#123; alert(&quot;网络繁忙，请稍后重试。&quot;); &#125; &#125;) 项目会大量的调用ajax，如果每次我们都去单独写ajax会让项目代码非常臃肿，我们应该将ajax封装起来，可以根据上面的知识来封装ajax 思路分析ajax主要有三个地方会变化：1、请求的servlet 2、传给servlet的参数 3、请求成功调用的方法。 我们可以用变量代替这些数据，下面是一个注册查询数据库是否已存在用户名的ajax请求 123456789101112131415161718192021222324252627//封装一个ajax方法，这里execute是请求成功执行的方法//servlet是去请求的servlet，val传过去的参数function to_ajax(execute,servlet,val)&#123; $.ajax(&#123; url: servlet, method: &quot;post&quot;, data: &#123; username: val, &#125;, success: function(data)&#123; execute(data) &#125;, error: function()&#123; alert(&quot;网络繁忙，请稍后重试。&quot;) &#125; &#125;)&#125;//定义ajax请求成功执行的方法function check_name_to_db(data)&#123; if(data==&quot;0&quot;)&#123; $(&quot;#name_detail&quot;).html(&quot;该称呢已被注册&quot;); $(&quot;#title_name&quot;).css(&quot;display&quot;,&quot;block&quot;); name_status = 0; &#125;&#125;//调用这个ajax方法to_ajax(check_name_to_db,&quot;Checkname&quot;,&quot;zhangsan&quot;); 这个函数还可以进一步封装，主要在于参数的传送，毕竟每次ajax传送的参数数量都不一定相同，要解决这个问题需要运用java面向对象的思维，将参数作为一个对象传送给服务器端，例如上传文件的时候将参数封装到FormData对象里面 12345var formdata = new FormData();//想formdata里面添加数据formdata.append("file",file);//调用ajax方法up_ajax(req_success,"Mybook",formdata) 参数的封装js函数的参数都是封装到一个名为arguments的数组里面，里面按照从前到后顺序存放参数，例如： 12345678//定义被调用的函数function say()&#123; console.log(&apos;Hello&apos; + arguments[0] + arguments[1] + arguments[2]); console.log(arguments.length);&#125;//调用函数say(&quot;World！&quot;, &quot;ByeBye!&quot;,&quot;gogo!!&quot;); 控制台打印结果是HelloWorld！ByeBye!gogo!!，由此可见，我们使用函数的时候可以写10个8个实参，但是定义的时候 不写形参也可以。 最终封装结果，封装了一个上传组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445//下面是上传文件使用的ajax方法function up_ajax(execute,servlet,val_data)&#123; $.ajax(&#123; url: servlet, method: "post", data: val_data, //将datatype改为text放在上传成功却进入error方法 dataType : "text", processData: false, // 注意：让jQuery不要处理发送的数据 contentType: false, // 注意：让jQuery不要设置contentType请求头 success: function(data)&#123; execute(data); &#125;, error:function()&#123; alert("网络繁忙，请稍后重试！") &#125; &#125;)&#125;function upload_book()&#123; //$("#upload_book").prop("files")是获取files属性的值，返回的结果是一个数组 //这个数组里面有两个键值对 0:file,length:1，通过key为0获取file文件 //file是一个file对象，里面封装了上传的文件的各种属性 var file = $("#upload_book").prop("files")["0"]; //获取文件的大小，将单位转为m var size = file.size/1024/1024; //如果上传文件的大小超过3M就不让上传 if(size&gt;3)&#123; alert("上传文件过大"); &#125;else if(size&lt;=0)&#123; alert("不能上传空文件"); &#125;else&#123; //由于上传的是二进制文件，需要创建FormData对象 var formdata = new FormData(); //想formdata里面添加数据 formdata.append("file",file); //调用ajax方法 up_ajax(req_success,"Mybook",formdata) &#125;&#125;//上传成功调用function req_success()&#123; var data = arguments[0]; console.log(data);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java发送手机短信认证码]]></title>
    <url>%2Fjava_yzm.html</url>
    <content type="text"><![CDATA[一直都有个技术梦想，做出属于自己的门户网站，业余时间都投入网站建设里面，由于网站需要手机认证来实现手机号找回密码功能，对于短信认证码的需求非常强烈，经过几天的研究，终于实现了这个功能(开心)，下面记录一下： 准备工作​ java上要实现短信认证码的功能，首先要具备一下几点条件： ​ 1、实名认证的阿里云账户 ​ 2、已认证的短信签名和短信模版 ​ 3、云服务器密钥 ​ 4、配置完整的tomcat以及servlet环境 ​ 5、阿里云配套的短信功能jar包 实名认证的阿里云账户需要你自己去搞定，作为一名有激情的后台开发工程师，云服务器对你的好处非常大，除了短信服务，还有其他好用的功能，像人脸识别，图形功能等等。这里我假定你已经有了可用的阿里云账户。主要介绍剩下的4点： 短信签名和短信模版首先我们要了解短信签名和短信模版的概念，短信签名是短信前缀，一般是网站名称或者用户名称，短信模版就是短信的内容，如下图，短信签名是”明阳图书”，短信模版就是后面一长串的内容 由于互联网环境监管严格，我们网站发送的短信内容都需要结果审核，不然就无法发送哦，下面是具体步骤： 登录阿里云帐号，在搜索栏输入”短信服务” 选择立即开通，由于我已经开通了，样式和你不一样 开通短信服务后找到管理控制台 点击签名管理 点击右上角添加签名 后面的内容也没啥可说的，按照官网提示填写内容，提交审核就行了，一般两个小时就有结果啦，短信模版步骤也是一样的 云服务器密钥云服务器密钥是包括两个部分，Access Key ID和Access Key Secret，这相当于你阿里云的账户和密码，和普通帐号的使用场景不同，对你的阿里云拥有最高的权限，所以千万不要把自己的密钥透露给别人哦！ 点击接口调用，获取AK 点击右上角的创建AccessKey 将创建的密钥保存到桌面，待会备用 tomcat以及servlet环境这个我之前的博客有详细的介绍，传送门 短信功能jar包阿里云短信服务需要两个jar包，可以去阿里云官方sdk下载，我这里也有提供，点击下载，密码：fjhx 下完将jar包导入到你的web项目中，注意要先把jar包复制到web目录里面再导入，不然上了生产环境会找不到jar包 好啦，所有的准备工作都已经完成，下面我们在java里面调用，按照注释修改即可，无需修改的地方不要动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.aliyuncs.DefaultAcsClient;import com.aliyuncs.IAcsClient;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest;import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse;import com.aliyuncs.exceptions.ClientException;import com.aliyuncs.exceptions.ServerException;import com.aliyuncs.http.MethodType;import com.aliyuncs.profile.DefaultProfile;import com.aliyuncs.profile.IClientProfile;//发送短信认证码public class Util_fsdx &#123; public static String get_code(String phone) throws ServerException, ClientException&#123; //验证码 String code = "123456"; //设置超时时间-可自行调整 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化ascClient需要的几个参数 final String product = "Dysmsapi";//短信API产品名称（短信产品名固定，无需修改） final String domain = "dysmsapi.aliyuncs.com";//短信API产品域名（接口地址固定，无需修改） //替换成你的AK final String accessKeyId = "XXXX";//你的accessKeyId final String accessKeySecret = "XXXX";//你的accessKeySecret //初始化ascClient,暂时不支持多region（请勿修改） IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象 SendSmsRequest request = new SendSmsRequest(); //使用post提交 request.setMethod(MethodType.POST); //必填:待发送手机号。支持以逗号分隔的形式进行批量调用，批量上限为1000个手机号码,批量调用相对于单条调用及时性稍有延迟,验证码类型的短信推荐使用单条调用的方式；发送国际/港澳台消息时，接收号码格式为00+国际区号+号码，如“0085200000000” request.setPhoneNumbers("XXXX"); //必填:短信签名-可在短信控制台中找到 request.setSignName("XXXX"); //必填:短信模板-可在短信控制台中找到 request.setTemplateCode("XXXXX"); //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 //友情提示:如果JSON中需要带换行符,请参照标准的JSON协议对换行符的要求,比如短信内容中包含\r\n的情况在JSON中需要表示成\\r\\n,否则会导致JSON在服务端解析失败 request.setTemplateParam("&#123;\"code\":\""+code+"\"&#125;"); //可选-上行短信扩展码(扩展码字段控制在7位或以下，无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("yourOutId"); //请求失败这里会抛ClientException异常 SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); if(sendSmsResponse.getCode() != null &amp;&amp; sendSmsResponse.getCode().equals("OK")) &#123; //请求成功 System.out.println("请求成功，验证码是" + code); &#125; return code; &#125; 说明由于阿里云只是负责发送给用户手机，不会返回验证码给后台，所以我们需要先用java后台生成短信验证码，可以使用Math类里面的random()生成6个0到10之间的随机整数拼接为一个验证码，这个我也为你写好啦 12345//生成验证码 String code = ""; for(int i=0;i&lt;6;i++)&#123; code = code + (int)(Math.random()*10); &#125; 由于后台很多servlet需要用到短信服务，我建议你将以上代码封装为一个静态方法，以后就可以多次调用了哦！ 同一个签名对同一个手机号发送验证码是有限制的，5分钟以内3条，1个小时以内5条，24个小时以内10条，这个时间间隔是以发送上限条数的时间点为准的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录建站遇到的各种问题]]></title>
    <url>%2Fjava_project.html</url>
    <content type="text"><![CDATA[中文乱码导入html文件乱码用过sublime text3后我就迷上了sublime的快捷键，相比之下用myeclipse写感觉好慢，所以一般前端代码我都是用sublime写完后再导入到myeclipse里面，但是有的时候会有中文乱码的现象，由于myeclipse默认使用GBK的编码，我们需要改为 utf-8才能正常使用，有两处地方要改 1、改变servlet项目的编码为utf-8 右键项目，选择Priperties，搜索Resource，改变编码为utf-8 2、改变myeclisp的编码为utf-8 ，找到window -&gt; preference -&gt;general -&gt;workspace，将编码改为utf-8 这里也顺便解决了另外一个问题，就是js文件报错的问题 myeclipse打开html文件缓慢由于myeclipse默认使用可视化打开，所以会消耗不少时间，我们需要改变打开方式 有两种方式 1、右键文件openwith -&gt;MyEclipse HTML Editor 2、改变默认打开方式 window -&gt; preference -&gt; 搜索file 找到File Associations,如图 选中html文件，然后在下方框框里面选择MyEclipse HTML Editor,点击Default，就可以啦 其他的文件觉得慢也可以按照这种思路做相应的改动 JDBC插入数据报错查询的时候使用 1stmt.executeQuery(sql); update或者insert操作的时候，使用 1stmt.execute(sql); 数据库乱码我之前插入数据的时候，数据的中文数据变成了？？？，在网上找了半天，发现网上很多答案有错误，这里指正一下 思路是在getConnection()里面增加两个设置编码的参数，useUnicode和characterEncoding 1conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/users?useUnicode=true&amp;characterEncoding=utf8"); 但是网上很多答案都把characterEncoding=utf8写成了characterEncoding=utf-8，搞了我好久，这里特别强调一下。 网站速度慢在网站注册功能，登录功能和个人主页功能完成的时候，我发现了一个问题，网站速度慢，Google了一下，才发现我的请求全部用的重定向(头疼)，当初建站的时候没注意这一点(伤心) 这里说明一下请求重定向和请求转发的区别，比如说从a.servlet到b.servlet 重定向走的路： 浏览器-&gt;a.servlet-&gt;浏览器-&gt;b.servlet 转发走的路：浏览器 -&gt; a.servlet -&gt; b.servlet 重定向明显走的路多一点，这还只是一个流程，如果有多个流程，那速度简直是天差地别啦 下面总结一下重定向和转发的特点： 请求转发：请求转发的过程全部会在服务器完成，经过多个servlet流程浏览器也看不到，明显比较安全，而且每次转发都会把当前request和response域对象传过去，所有流程都是用的同一个request和response对象，数据好取，而且由于不用通知客户端，速度明显快很多，就是不能请求外部服务器。 请求重定向：可以请求外部服务器，由于我的站点不用请求别的服务器，这一点跟没有一样，可以说被请求转发全方面碾压。 浏览器上方url会改变，由于浏览器url改变我们的servlet不会暴露出来，对于服务器安全性有很大的提高，建议后台的最后一个请求使用重定向，前面所有请求用转发 注意：改了请求方式后在jsp要指定meta的href的值，不然会找不到样式，因为请求转发不会通知浏览器地址改变，也就是说浏览器用的地址一直都是第一个servlet的地址，下面是解决方法： 步骤一：在jsp上面加上这两句话 12String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; 步骤二： 在jsp的head标签里面要加&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;标签 request.getScheme()表示站点使用协议 request.getServerName()表示站点主机，本地就是localhost request.getServerPort()表示站点端口号 request.getContextPath()表示站点项目名称 最后的basePath是一个完整的url，比如我的url是： 1http://localhost:8080/servletPro/ 然后将href指定为这个地址，以后写相对路径就是相对这个地址来的 java流换行问题使用java流操作文件的时候，发现缓冲字符流BufferedWriter里面有一个方法readLine()可以一行一行的读取数据，相比FileWriter一个字符一个字符的读取快了很多，但是不会读取换行符号，需要我们手动添加换行符，由于在不同的操作系统上换行符不同： 123mac: \r linux: \nwindow: \r\n 可以使用java里面的System.getProperty(“line.separator”)自动获取空格来解决这个问题]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器ECS建站攻略]]></title>
    <url>%2Faly_java_tomcat.html</url>
    <content type="text"><![CDATA[最近买了阿里云的ECS产品，之前一直没有建站，因为我以为要先备案才能访问服务器，浪费了大半个月的时间(捂脸)。 这里先纠正一下概念，不管有没有备案，买了服务器就可以搭建自己的网站，只是地址不好记住，比如说我的地址是 43.25.118.37，那我的网站地址可能是 1http://43.25.118.37:8080 如果我购买了一个域名ganmyds.cn，成功备案并且解析到43.25.118.37上,那我的网站地址就是 1http://ganmyds.cn:8080 这样相对来说比较好记住。 由于我是学java的，自然建站后台也是选择java环境，这里强调一下我的环境 linux系统centos6.8 64位+jdk1.8.0+tomcat8.0 其他环境这里就不说了，下面开始环境搭建流程： ECS管理软件下载这里推荐两款软件用来管理ECS服务器，使用xshell远程连接终端，用xftp可以从你的电脑传文件到云服务器上 下载： xshell xftp 软件使用方法双击xshell.exe，新建会话 帐号密码没有输错就可以进入，然后我们要传文件的话，点击传输新文件就可以打开xftp 这里xftp的地址和你的linux地址是一致的，假如你想传文件到/usr/java/tomcat/里面，可以在xshell里面先切换到这里去 1cd /usr/java/tomcat/ 然后在点击传输新文件就可以快速传输文件了 环境搭建由于tomcat是用java写的，所有我们肯定要先搭建java环境，下载jdk 下载tomcat 创建目录12345cd /usr mkdir javacd javamkdir tomcatmkdir jdk 然后我们把jdk-8u171-linux-x64.tar.gz.tar.gz.tar.gz放到jdk里面，把apache-tomcat-8.5.31.tar.gz放到tomcat里面 配置jdk环境变量123cd jdktar -zxvf jdk-8u171-linux-x64.tar.gz.tar.gz.tar.gzvi /etc/profile 在里面对应路径加上下面内容 1234export JAVA_HOME=/usr/java/jdk/jdk1.8.0_171export JRE_HOME=/usr/java/jdk/jdk1.8.0_171/jreexport CLASSPATH=.:$JAVA_HOME/lib$:JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin/$JAVA_HOME:$PATH 如图： 退出登录 1logout 关闭xshell重新打开就可以了 1java -version 如图就表示成功了 安装tomcat1234cd /usr/java/tomcat/tar -zxvf apache-tomcat-8.5.31.tar.gzcd apache-tomcat-8.5.31.tar.gz/binvi setclasspath.sh 在最下面加上内容 12export JAVA_HOME=/usr/java/jdk/jdk1.8.0_171export JRE_HOME=/usr/java/jdk/jdk1.8.0_171/jre 启动tomcat 1./startup.sh 有Tomcat started就表示成功启动 然后在浏览器输入http://云服务器的ip:8080就可以访问了 好的，服务器终于搭建好了，由于tomcat默认是8080端口，我们的网站需要输入端口号，这个对于网站的推广是不好的，我们现在改为80端口 修改配置文件在window上只需要编辑tomcat/conf/server.xml，找到 123&lt;Connector URIEncoding="UTF-8" port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 把port改为80就可以了 假如你的用户不是root这样不行，因为linux上非root用户不能监听1024以下的端口号，我们可以用linux的端口转发机制，输入 1iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 保存 1service iptables save 安全组改动如图修改 按如图填写 还要配置8080的端口 重启tomcat我们改动了配置文件需要重启tomcat才能生效，但是在linux上只能通过结束进程的方式关闭tomcat，我们得先找到tomcat的进程id，由于tomcat默认监听8080，我们可以通过这一点来找 1netstat -anp | grep 8080 找到对应的进程编号，如图是我的进程编号，5881 结束5881就可以了 1kill -9 5881 然后启动就可以了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的的bootstrap学习之路]]></title>
    <url>%2Fbootstrap_summed.html</url>
    <content type="text"><![CDATA[使用bootstrap框架开发可以极大的提高开发效率，bootstrap有以下优点： 1、响应式设计，bootstrap的设计无时不刻都是适应移动端的，我们不需要再特地写响应式了，提高效率 2、浏览器兼容，我以前就喜欢bootstrap这一点，我不会用bootstrap的时候会引用normalize.css，normalize.css是从bootstrap剥离专门做浏览器兼容的问题。 3、不需要自己取名字，说实话类名真的不好取，bootstrap里面把类名都给我们写好了，直接引用就可以了 由于bootstrap要记太多东西了，好记性不如烂笔头，我打算用这篇文章记录bootstrap的一些常用内容。方便开发的时候直接查阅 引用bootstrap点击下载 我用的是版本是3.3.5。 栅格系统bootstrap将屏幕分为12等分，类名前面都co-为前缀,col的全称是column，中文翻译是列，例如想要4等分，每一份长度是屏幕宽度的三分之一就用col-md-3 123456789101112&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. &lt;/div&gt;&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt;&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. &lt;/div&gt;&lt;div class="col-md-3"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/div&gt; 这个样式是响应式布局的，在手机上自动变为摞起来的样式，假如想让响应式布局生效的范围更小，只需要改md就行 范围从大到小依次是： 1234col-lg-3 //lagrecol-md-3 //mediumcol-sm-3 //smallcol-xs-3 //extra small 用的最多的是md和sm，一般很少用xs，因为xs不管屏幕多小都不会应用相应式。还是感觉这个bootstrap的栅格系统非常强大，原来不用bootstrap的时候我要实现这个功能要写不少的代码，现在直接引用就可以了。 表单表单在网页上的应用是非常多的，基本上每个网站都有登录注册输密码的页面，这些页面都是用表单做的。下面是一些例子： 常用表单：1234567891011&lt;form class="container" style="max-width: 550px;"&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;div class="form-group"&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="password" class="form-control"&gt; &lt;/div&gt;&lt;/form&gt; 效果如图： 这里最重要的样式就是form-control，给input用的，form-group的只是是添加15px的margin-bottom。 内联表单12345678910111213&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="form-inline"&gt; &lt;h1 style="margin-bottom:15px;"&gt;注册&lt;/h1&gt; &lt;div class="form-group"&gt; &lt;label&gt;姓名&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 这个样式只是多嵌套了一层form-inline的div，并且在手机上面和上面显示一样，感觉更加具有通用性 验证结果表单12345678910111213&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="form-inline"&gt; &lt;h1 style="margin-bottom:15px;"&gt;注册&lt;/h1&gt; &lt;div class="form-group has-error"&gt; &lt;label class="control-label"&gt;姓名&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 另外bootstrap还提供了其他验证结果的样式，比方说验证成功是has-success，验证警告是has-warning。 充值金额表单123456789&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="form-group"&gt; &lt;label style="margin-top: 15px;"&gt;充值金额&lt;/label&gt; &lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;￥&lt;/div&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 效果如图： 密钥表单12345678910111213141516&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="row" style="margin-top: 15px;"&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;div class="col-sm-3"&gt; &lt;input type="text" class="form-control" placeholder="XXXX"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 效果如图： 这种表单结合了通用表单和栅格系统，其实和上面差不多。 按钮一般按钮相比表单，按钮的应用更广，几乎所有页面都有按钮，按钮的处理也相对简单，bootstrap提供了5种情况的按钮，分别是 12345&lt;button class="btn btn-default"&gt;你好&lt;/button&gt; //默认按钮&lt;button class="btn btn-primary"&gt;你好&lt;/button&gt; //主色调按钮&lt;button class="btn btn-danger"&gt;你好&lt;/button&gt; //危险按钮&lt;button class="btn btn-warning"&gt;你好&lt;/button&gt; //警告按钮&lt;button class="btn btn-info"&gt;你好&lt;/button&gt; //信息按钮 代码： 123456789&lt;form class="container" style="max-width: 550px;"&gt; &lt;div style="margin-top:15px;"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-primary"&gt;你好&lt;/button&gt; &lt;button class="btn btn-danger"&gt;你好&lt;/button&gt; &lt;button class="btn btn-warning"&gt;你好&lt;/button&gt; &lt;button class="btn btn-info"&gt;你好&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 效果如下： 其他标签像a标签和input的submit标签也可以使用这些样式，大小也是可以调整的。 12345678910&lt;form class="container" style="max-width: 550px;"&gt; &lt;div class="margin-t15"&gt; &lt;button class="btn btn-default btn-lg"&gt;你好&lt;/button&gt; &lt;button class="btn btn-primary"&gt;你好&lt;/button&gt; &lt;button class="btn btn-danger"&gt;你好&lt;/button&gt; &lt;button class="btn btn-warning btn-sm"&gt;你好&lt;/button&gt; &lt;button class="btn btn-info btn-xs"&gt;你好&lt;/button&gt; &lt;button class="btn btn-block btn-danger" style="margin-top: 15px;"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 在手机银行的项目上btn-block用的最多。 按钮组在很多后台项目像什么管理平台会用到按钮组，这里也写一下： 123456789101112131415161718192021222324252627282930&lt;form class="container" style="max-width: 550px;"&gt; &lt;!--按钮组--&gt; &lt;div class="margin-t15"&gt; &lt;div class="btn-toolbar"&gt; &lt;!--按钮组是btn-group--&gt; &lt;div class="btn-group btn-group-lg"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;div class="btn-group"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;div class="btn-group btn-group-sm"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="margin-top:15px;"&gt; &lt;div class="btn-group-vertical"&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;button class="btn btn-default"&gt;你好&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 效果如图： 下面默认添加样式 1234body&#123; max-width: 400px; margin: 20px auto;&#125; 导航关于导航栏，主要有下面4种： 知乎导航123456789&lt;ul class="nav nav-tabs"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor.&lt;/div&gt; 效果如下： 这里说明一下，在nav-tabs后面加上nav-justified的类可以是导航按钮变得更宽 123456789&lt;ul class="nav nav-tabs nav-justified"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor.&lt;/div&gt; 效果如下： 普通导航123456789&lt;ul class="nav nav-pills"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor.&lt;/div&gt; 效果如下： 侧边栏导航123456789101112131415&lt;div class="row"&gt; &lt;div class="col-xs-4"&gt; &lt;ul class="nav nav-pills nav-stacked"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;忘记密码&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="col-xs-8"&gt; &lt;div&gt; &lt;h1&gt;登录&lt;/h1&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptates tempore minus similique doloribus, at error odio laudantium ad blanditiis neque inventore pariatur voluptate quis exercitationem? Nulla cumque labore magnam dolor. &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 其实这个只是普通导航和栅格系统的组合使用 导航栏1234567891011121314151617181920&lt;div class="navbar navbar-default"&gt; &lt;div class="navbar-header"&gt; &lt;div class="navbar-brand"&gt;名言网&lt;/div&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form class="navbar-form navbar-left"&gt; &lt;div class="form-group"&gt; &lt;input type="text" class="form-control"&gt; &lt;/div&gt; &lt;button class="btn btn-danger" type="submit"&gt;搜索&lt;/button&gt; &lt;/form&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;注册&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果如图： 由于导航栏需要占据屏幕整宽，这里没有限制body宽度，在navbar里面使用navbar-left或者navbar-right实现左对齐或者右对齐 面板1234567891011&lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt;用户统计&lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Blanditiis aperiam nostrum, hic voluptas, consequatur magni libero fugiat architecto at, excepturi quis distinctio, laboriosam eos. Ipsam voluptates maiores possimus magnam animi. &lt;/div&gt; &lt;div class="panel-footer"&gt; &lt;div class="small text-muted"&gt;数据更新于5秒前&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 这里text-muted和small主要是将字号变小并且改变颜色的，并且panel-default可以改成panel-success或者panel-warning 表格和表单不同，表格适用于统计信息的 12345678910111213141516171819202122232425262728293031&lt;table class="table table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;联系方式&lt;/th&gt; &lt;th&gt;注册于&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class="danger"&gt; &lt;td&gt;wanghuahua&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;tr class="success"&gt; &lt;td&gt;你阿飞&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;tr class="warning"&gt; &lt;td&gt;235432&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;tr class="info"&gt; &lt;td&gt;sgsg&lt;/td&gt; &lt;td&gt;wanghuanghuan1@com&lt;/td&gt; &lt;td&gt;2048年&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 效果如下： table-striped是用来加重基数行的颜色的，这里由于全部加上了颜色没有表现出来，可以改为table-hover用来相应鼠标滑动效果，想要边框可以在table里面添加类table-bordered 翻页123456789&lt;ul class="pagination"&gt; &lt;li&gt;&lt;a href="#"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;...&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;50&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;下一页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 效果如下 还有一种简单的翻页效果，主要是用于页数比较少的 1234 &lt;ul class="pager"&gt; &lt;li&gt;&lt;a href="#"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class="disabled"&gt;&lt;a href="#"&gt;下一页&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 效果如下： 文章头部12345 &lt;div class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;文章列表&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;yo. world &lt;span class="badge"&gt;15k&lt;/span&gt;&lt;/li&gt;&lt;/div&gt; 效果如下： 列表123456 &lt;div class="list-group"&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt; &lt;a href="#" class="list-group-item"&gt;Item&lt;/a&gt;&lt;/div&gt; 效果如下： 这种列表主要是用作侧边栏的 标签12345&lt;p&gt; &lt;span class="label label-success"&gt;面霜&lt;/span&gt; &lt;span class="label label-info"&gt;water baby&lt;/span&gt; &lt;span class="label label-danger"&gt;http&lt;/span&gt;&lt;/p&gt; 效果如下： 这种标签可以完美的嵌入文字中间]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客绑定域名]]></title>
    <url>%2Fhexo_realm.html</url>
    <content type="text"><![CDATA[刚开始接触hexo博客的时候，感觉非常惊奇，尤其是next主题自带的各种方便的功能，但是部署到github上面一直都有一些不满意的地方，觉得github的域名不好，主要有以下几个问题： 1、.github.io是二级域名，始终有种寄人篱下的感觉，是github上的附属域名 2、地址太长，像我之前的博客地址是： 1ganmyds.github.io/hexo_blog/ 我自己都记不住，就别说别人了。 3、.github.io不支持收录到百度上，也就是说你的博客别人搜索不到，这样博客基本就失去了一半的价值了 4、没有自己的域名很多功能不能实现，比方说网站浏览数，评论功能 所以我的域名备案好了之后马上就开始搞域名的调整，记录一下： 添加域名解析进入阿里云服务器管理平台，找到域名管理，点击添加解析 按照图片上的说明输入就可以了。 本地修改进入你的博客地址，找到source文件夹，创建一个CNAME文件,右键gitbash 1vi CNAME 然后键盘输入i,输入域名，保存，和linux的vi操作一样，然后hexo g，部署到github上就可以了，注意： 1、CNAME没有后缀，所以你最好用git来创建，不要创建一个txt文件然后把名字改成CNAME，这样很容易忘记去掉后缀，特别是有的电脑不显示后缀更麻烦 2、内容没有什么http:www，写域名部分就可以了，例如我的域名全称是 1http://ganmyds.cn 那我输入的部分就是ganmyds.cn github修改进入你的博客的github路径，找到setting 搜索Custom domain，把值改为你的域名，如图所示： 如果没有操作好，就会出现404报错，如图所示 网上很多绑定博客的教程都没有第三步，所以这里重点说明一下，有什么不懂的可以在评论里面说明哦！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我的阿里云备案经历]]></title>
    <url>%2FAlibabaCloud.html</url>
    <content type="text"><![CDATA[以前和同事一起做过一个网站项目，当时我负责前端页面搭建，他负责后端php系统，网站放在京东云上运行，那时候对云服务器有一丝好奇，无奈复用太贵，一直没买，后来群友发我一个链接，是阿里云优惠活动，活动时间是3月28号到4月13号，新用户专享，1年99，两年189，3年279，要知道没有活动的时候阿里云一个月的费用都要70多，我毫不犹豫的买了3年的服务器，一口气便宜了3300多，买服务器为了自己以后更好的学习吧！当时我也没想到备案花了我这么多的时间，先谈谈备案流程！ 备案流程注册域名​ 我们买了云服务器就自动得到一个公网ip地址，像百度的公网ip地址是 http://14.215.177.39/ ​ 一般这个ip地址非常不利于吃瓜群众记住，所以大部分网站都会注册一个域名，然后通过DNS服务实现域名和ip地址的绑定，这就是所谓的域名解析，注册域名的地址：传送门，一般com域名最贵,那些很长的后缀像什么club、online等等的域名就很便宜了，六七块钱一年，我最后还是选择了cn的后缀，也不贵而且相对较短，29元一年，反正几百都出了也不在乎这几十块了。 填写信息初审这里一般都要写准确的信息，像电话到时候会有阿里云那边的人打电话验证是不是你本人，然后地址要具体到房间号，非常严格的哦，所以为了不麻烦我们还是写清楚一些，这里要注意网站类型千万别写论坛，基本上论坛都会被各种理由拒绝的，还有网站名称不要带有工作室等等看起来很商业化的名称，我的网站类型是博客，网站名称是学习和成长，这样相对比较好通过审核，一般初审一个工作日就有结果了，我的初审经历非常坎坷，挂了两次(捂脸) 上传资料这一步就到了大家说的幕布阶段了，不过得益于技术的发展，广东、上海、重庆、辽宁、安徽、福建这些省份不用拍幕布上传了，只需要下载阿里云app，按照指示拍摄几个表情就可以了，非常方便。其他的省份还得申请幕布，当然幕布的申请是免费的，你不用出一分钱，但是还是很麻烦，而且要求很多，背景要被幕布完全覆盖、人得在幕布正中间、要拍出上半身、不能Ps等等 管局审核前面两次审核都是阿里云那边做的，这里就是有关部门审核的了，果然有关部门还是比较慢的，我是5月3号提交审核的，一直到5月11号才出结果，一共花了9天，还好我是一次过的，要是失败个两三次，那哭都没地方哭了，注意在管局审核这段时间，一定要保证ip地址是不能访问的哦！ 以上就是备案的基本流程了，现在说说我是怎么审核失败的，大家别踩我走过的这些坑哈！ 第一次备案初审没过，直接上图吧： 上面主要是说了三个问题： 1、主要联系手机号和应急联系手机号一样。 2、人脸识别失败(阿里云那边打电话说我做了一个鬼脸，黑人问号？我吃多了会在这种重要的场合做鬼脸呀！) 3、身份证地址不是福建省的，需要提供居住证或者暂住证 前面两个好处理，注意一下就能搞定，就是后面那个暂住证的问题真的难到我了，由于暂住证的办理非常麻烦并且备案省份不能修改，最后我还是放弃了这次备案。 第二次备案这次我换了省份，由于我的省份不在上面那六个省里面，上传资料这一步还是得乖乖拍幕布上传，但是，我的初审还是失败了，心酸！还是上图： 阿里云那边打电话过来说我的身份证有反光，我真是无语了，就那么一个小光点，有没挡住字，这样也不行，好在后来我重新拍照顺利通过了初审 这里不得不感叹阿里云的效率真的很快，一个小时就有了结果。初审通过了然后就是搞幕布的流程了，这是第二次审核，很幸运，这一次我一次就过了，上图： 后面的环节我也没什么可以说的了。初审通过后我好像得到了幸运女神的眷顾，审核都是一步通过，很多人在幕布环节都很容易挂，我有一个朋友在幕布里挂了3次，所以大家拍照的时候一定要仔细看要求哈，然后关于备案，阿里云有一个优惠，备多久送多久，这里我感觉阿里云还是比较有良心的，要是域名时间也送就好了(捂脸）！我的域名是ganmyds.cn，以后估计我的个人网站就用这个域名，到时候欢迎大家访问，最后在这里祝大家备案的时候都一次过，要是这篇文章对你有帮助的话就点个赞或者打赏一下哈!谢谢啦！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ps的一些经验]]></title>
    <url>%2Fps_start.html</url>
    <content type="text"><![CDATA[最近看百度贴吧ps吧笑出腹肌，很多人使用ps将照片变得非常有趣，感觉ps这个工具对于我们的日常生活有很大的作用，于是也开始学习ps的一些技巧，在这里记录一下。 ps下载安装ps全称是photoshop，网上有很多下载的地方，但是说实话，大多数都收费的，而且安装包巨大，我找了很多资源才找到破解版的，点击下载免安装版,密码是uznw 解压后打开，界面如下 将照片放到5寸白纸上改动图片大小我们先在网上随便下载一张证件照，按住ctrl+alt+i改变大小，这里说明一下： 一寸证件照长宽为： 2.54*3.62cm 两寸证件照长宽为：3.5*4.5cm 改动如下，改变红框里面的内容就可以了： 注意这里分辨率要改为300，不然照片会变得模糊 加上白边接下来我们给照片加上白边，按照ctrl+alt+c打开画布选项，改动如图： 现在你的照片就有白边了，效果如图 将照片放到5寸白纸上文件–&gt;新建，改动如图： 点击确定，出现了一张白纸，你之前的照片在红线部分那里 我们将鼠标放到红先部分直接拖到左侧，如图 选择移动工具，如图所示： 将我们的照片托动到白纸上，如图： 按住alt不动。开始拖动图片，如图我们就有了16张一寸照片了 照相馆里面的相片就是这么制作的，另外给大家说一个很有用的快捷键，撤销：ctrl+alt+z 侧面视角正面化我们去看画展的时候经常会拍照，但是有的时候在走廊只拍到侧面照，我们想将侧面照片转化为正面照片，就可以是用ps透视裁剪功能了，现在我们有一张画展走廊照片，如图 现在每一幅画都是侧面的，我们想看到某一幅画的正面，就可以使用ps的裁剪功能了，鼠标按住裁剪工具不动，选中透视裁剪工具，如图 选中你想查看的区域，可以先随便选一个区域然后自己慢慢调整，如图是我选择的区域 鼠标左键双击选中区域，我们就可以看到想要的效果了，如图]]></content>
      <categories>
        <category>photoshop</category>
      </categories>
      <tags>
        <tag>photoshop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo关于next主题的使用经验]]></title>
    <url>%2Fhexo_next.html</url>
    <content type="text"><![CDATA[ps: 之前用hexo写的博客一直有问题，首先是样式加载不到，我将hexo文件夹下的_config.yml里面的relative_link改为true之后就可以正常加载了，本来以为问题已经解决，但是替换next主题后陆陆续续各种路径找不到，索性就将hexo卸载重装，用了最新版本hexo后感觉世界都变得美好了，重新提交了blog，现在记录一下相关的配置。 hexo卸载重装卸载hexo，3.0.0之前版本执行 1npm uninstall hexo -g 3.0.0之后版本执行 1npm uninstall hexo-cli -g 查看hexo版本 1hexo -v 安装最新版hexo 1npm install hexo-cli -g ps：npm删除模块通用命令： 12npm uninstall xxx //删除模块npm uninstall -g xxx //全局删除模块 next主题安装下载next主题​ 进入你的博客下的themes文件夹下，目录结构类似Hexo\blog\themes，输入 1git clone https://github.com/iissnan/hexo-theme-next themes/next ​ 会下载一个next文件夹，如图所示 修改主题​ 找到Hexo\blog\\_config.yml(貌似别的博客都称这个文件为站点配置文件，下面我也怎么称呼吧！)，将theme原来的landscape改为next,如图 ​ 重启服务，在git里面输入 1hexo s 其他功能的添加配置语言​ 现在你的主题就成功改好了，但是还有一些小小的问题 ​ 我们找到Hexo\blog\themes\next_config.yml，搜索title，修改如下: 12345678# Sitetitle: 小小程序员subtitle: 记录学习过程中的点点滴滴description: 技术与生活，与我融为一体keywords: linuxauthor: 甘明阳language: zh-Hanstimezone: ​ 然后我们去Hexo\blog\themes\next\_config.yml，搜索scheme，如图： 这里有四种样式可以供我们选择，记住，有一个要去掉#，然后其他三个要加上# 添加头像​ 我们要加上自己的头像，在这个文件里搜索avatar，如图： ​ 将avatar的值改为我们自己的图片路径，如图 添加社交链接​ 还是在当前文件，搜索social，添加如下： 123456social: github: https://github.com/your-user-name twitter: https://twitter.com/your-user-name weibo: http://weibo.com/your-user-name douban: http://douban.com/people/your-user-name zhihu: http://www.zhihu.com/people/your-user-name ​ 内容可根据需求增减 添加背景音乐​ 使用hexo搭建的博客添加背景音乐非常简单，不同的主题改动稍微会有一点差别，以next主题为例，我们打开网易云随便搜索一首歌，以未闻花名为例，点击进去 点击生成外链播放器 选择不同的播放模式代码会不一样，想一进页面就播放音乐就选择自动播放，否则自动播放的对钩不要点，然后我们复制下面的代码 进入hexo/themes/next/layout/_macro,找到sidebar.swig,搜索links-of-blogroll，使用这个类的div是用来放置外链的，我们将复制的代码放到下面就可以了，如图： 然后，在git里面输入 1hexo g 1hexo s 现在打开localhost:4000就有效果了，如图 点击进入我的博客看看效果 添加字数统计功能​ 需要安装一个控件hexo-wordcount，在Hexo\blog\目录下安装，输入： 1npm install hexo-wordcount --save ​ 之前我在这一步遇到了一个报错，内容是 12345678910111213141516npm ERR! path C:\Users\home\Desktop\hexo_blog\blog\node_modules\minipass\node_mo dulesnpm ERR! code EPERMnpm ERR! errno -4048npm ERR! syscall scandirnpm ERR! Error: EPERM: operation not permitted, scandir 'C:\Users\home\Desktop\h exo_blog\blog\node_modules\minipass\node_modules'npm ERR! &#123; Error: EPERM: operation not permitted, scandir 'C:\Users\home\Deskto p\hexo_blog\blog\node_modules\minipass\node_modules'npm ERR! stack: 'Error: EPERM: operation not permitted, scandir \'C:\\Users\\h ome\\Desktop\\hexo_blog\\blog\\node_modules\\minipass\\node_modules\'',npm ERR! errno: -4048,npm ERR! code: 'EPERM',npm ERR! syscall: 'scandir',npm ERR! path: 'C:\\Users\\home\\Desktop\\hexo_blog\\blog\\node_modules\\minip ass\\node_modules' &#125;npm ERR!npm ERR! Please try running this command again as root/Administrator.npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\home\AppData\Roaming\npm-cache\_logs\2018-04-23T04_26_33_4 54Z-debug.log 在网上搜索了很多都没有看到有类似这个问题的，我感觉有可能是路径的问题，于是关掉本地服务器打算切换路径安装，结果有事忙忘了切换路径，居然成功安装了，原来原因是没有关掉本地服务器，囧！这里记录一下。 安装成功后，我们去主题配置文件里面搜索post_wordcount，改成如下配置 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 刷新一下，字数统计功能就有了，但是现在是没有单位的 到Hexo\blog\themes\next\layout\_macro\post.swig 路径下 搜索wordcount(post.content)和min2read(post.content)，修改如下 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;字&lt;/span&gt; 123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125;分钟&lt;/span&gt; 首页添加分页功能分页功能需要下载对应的插件，git切换到Hexo\blog\依次输入： 1npm install hexo-generator-index --save 1npm install hexo-generator-archive --save 1npm install hexo-generator-category --save 1npm install hexo-generator-tag --save 到站点配置文件里面，搜索index_generator，修改如下： 1234567891011121314#首页分页设置index_generator: path: '' per_page: 5 #这里是配置5篇文章一页 order_by: -date#归档页的分页设置archive_generator: per_page: 30 yearly: true monthly: true#标签页的分页设置tag_generator: per_page: 20 添加标题图片之前在网上看到很多人的博客都配置了标题图片，感觉这样挺好看的，于是也想搞一下，没想到在网上找了半天都搜不到答案，估计是我没有描述清楚问题，感觉描述能力也挺重要的，反正我费了老大的劲才找到答案，现在记录一下： 其实很简单，我们主要在每个md文件的前面加上photos配置信息就可以了，如下： 123456789---title: hexo关于next主题的使用经验date: 2018-04-17 10:42:00 tags: [hexo] categories: hexo description: 记录hexo博客各种功能的添加，包括国际化、头像、社交链接、背景音乐等11photos: - "http://oz2tkq0zj.bkt.clouddn.com/17-11-9/52323298.jpg"--- 添加个性宠物个性宠物需要安装插件，切换到Hexo\blog\目录下，输入 1npm install -save hexo-helper-live2d 打开Hexo/blog/themes/next/layout,找到_layout.swig，,将下面代码放到&lt;/body&gt;之前： 1&#123;&#123; live2d() &#125;&#125; 然后在在 hexo 的 _config.yml中添加参数： 123live2d: model: wanko bottom: -30 然后hexo clean一下就行了 下面是所有宠物的名称，默认宠物是z16 Gantzert_Felixander Epsilon2.1 haru miku ni-j nico nito nipsilon nietzsche shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki width 宽度 默认值: 150，height 高度 默认值： 300，className &lt;canvas&gt;元素的类名 默认值： live2d， id &lt;canvas&gt; 元素的id 默认值： live2dcanvas，bottom &lt;canvas&gt; 元素的底部偏移 默认值： -20 如果嫌模型位置不正确 可以调整这个参数 ps：如果不想在手机上显示宠物，修改配置文件如下： 1234live2d: model: wanko bottom: -30 mobileShow: false 备案号的添加找到文件 1themes\next\layout\_partials\footer.swig 找到如下部分 12345678&lt;div class="copyright"&gt;&#123;##&#125;&#123;% set current = date(Date.now(), "YYYY") %&#125;&#123;##&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;##&#125;&lt;span itemprop="copyrightYear"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class="with-love"&gt; &lt;i class="fa fa-&#123;&#123; theme.footer.icon &#125;&#125;"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; theme.footer.copyright || config.author &#125;&#125;&lt;/span&gt; 改成 123&lt;div class="copyright"&gt;&#123;##&#125; &lt;span class="author" itemprop="copyrightHolder"&gt;浙公网安备 XXXX号&lt;/span&gt; seo优化一个博客不做seo优化是很难被百度爬虫爬取的，下面记录next主题的seo优化方面 网站自身优化减少无用链接的爬取，增加网站的权重，我们要给没用的链接添加rel=”external nofollow”的属性，让爬虫不爬取这个链接 找到文件： 1themes\next\layout\_partials\footer.swig 和文件 1themes\next\layout_macro\sidebar.swig 在所有a链接上加上rel=”external nofollow”的属性 首页title的优化找到文件： 1themes\next\layout\index.swig 将下面代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 改为 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 缩短链接长度hexo默认的链接格式是4级url，堆爬虫是非常不友好的，建议改一下，编辑站点_config.yml文件，，修改其中的permalink字段改为permalink: :title.html即可。 处理一些next的问题分类和标签按钮不能点击​ next目前没有分类和标签页面，需要我们手动添加，首先添加分类页面，在git命令行里面输入： 1hexo new page categories 完成后在source里面生成一个categories文件夹，我们进入Hexo\blog\source\categories，找到index.md，改动如下： 123title: categoriesdate: 2018-04-17 15:47:33type: "categories" 然后在git命令行里面输入: 1hexo g 刷新页面，分类按钮就能点击了。 然后添加标签页面，输入： 1hexo new page tag 进入Hexo\blog\source\tag，找到index.md,改动如下 123title: categoriesdate: 2018-04-17 15:47:33type: "tags" 剩下的步骤同上。 点击首页回不去 这个要看你的博客是不是处于子目录里面，例如我的博客路径为 1https://ganmyds.github.io/hexo_blog/ 就是有子目录,下面就是不含子目录 1https://ganmyds.github.io/ 如果你是将博客放在子目录里面，找到Hexo\blog\themes\next\_config.yml，搜索menu内容类似下面： 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 将内容改为你博客的对应链接就可以了，例如我的改动是： 123456789menu: home: https://ganmyds.github.io/hexo_blog/ # about: /about/ || user tags: https://ganmyds.github.io/hexo_blog/tags/ || tags categories: https://ganmyds.github.io/hexo_blog/categories/ || th archives: https://ganmyds.github.io/hexo_blog/archives/ || archive # schedule: schedule/ || calendar # sitemap: sitemap.xml || sitemap # commonweal: 404/ || heartbeat]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicate for Mysql的破解]]></title>
    <url>%2FNavicate_Mysql.html</url>
    <content type="text"><![CDATA[开发项目的时候经常会查询数据库的状态，每次都跑云服务器上查询感觉很麻烦，我现在郑重介绍一个好用的工具navicate，用过这个工具我真是爱上它啦，“这人用mysql不搭配navicate是不是傻”，工作中我经常会有这种想法，除了建表的便捷性，还可以设置各种查询彻底解放你的双手哦~ 下载安装首先这个工具需要我们的电脑上安装了mysql,如果你的电脑上没有安装mysql，点这里下载免安装版的：点击下载 密码是：o2mb 在D盘创建一个文件夹mysql,然后解压到这个文件夹，双击bin下面的mysqld.exe打开，如图 会有一个黑窗口一闪而过，我们不用管他，打开任务管理器看看是不是有一个mysqld.exe的进程在运行，如图： 如果有就说明你的mysql已经成功运行，接下来我们下载Navicate for Mysql和相关的破解文件，点击下载 密码：5t6d 下载找到navicat111_mysql_cs_x86.exe，双击安装，安装后找到安装的路径，会多一个文件夹Navicat for MySQL，然后我们把压缩包里面的PatchNavicat.exe复制到Navicat for MySQL下，如图 开始使用双击打开，选中navicte.exe，弹出一个success的框框就说明破解成功，然后我们双击navicte.exe打开，点击连接，如图： 选择mysql,输入如图，密码是root 建表首先建立数据库users： 建表，首先设置id为主键，点钥匙就可以取消主键 点击添加栏位添加新列 保存，写表的名字，注意公司都是以T_ 开头，复数结尾，比如T_students，前面不能有空格 修改表注意这里不能双击表名，要右键选择设计表，假如我想删除一列，右键这里点删除栏位 如果像查看表里面有哪些数据，直接双击表名就可以了 现在啥都没有，我们插入两条数据，点击加好可以添加一行新的 基本操作就这些，然后是关于mysql的存储引擎，最常用的是InnoDB和MyISAM，MyISAM效率较高，但是不支持事务，外键约束等属性，因此一般都用InnoDB，新版本默认使用InnoDB，建表的时候想要选择引擎点击选项，如图 建完表后想要查看引擎，对表右键选择对象信息 命令行使用切换到查询 点击新建查询 查询 增加数据 注意字符串要用单引号引起来，修改也可以 快捷查询点击保存，你的sql语句就保存下来了 以后想要查询所有数据，点击查询-&gt;查询所有数据-&gt;运行就可以啦]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧妙解决hexo博客使用的图片的处理]]></title>
    <url>%2Fhexo_img.html</url>
    <content type="text"><![CDATA[使用github和hexo搭建博客一段时间了，感觉图片的处理还真是挺麻烦的，有两个问题： 1、因为自己的博客经常要修改，会很频繁的使用hexo clean这个命令，经常会把图片清空，然后又要重新导入图片 要特别注意路径的处理，感觉挺浪费时间的 2、github提供的空间只有1g,图片会占用非常多的空间，对自己github未来的使用有负面影响 于是，根据这些问题，查阅了一些资料，找到了一个很好的处理方法，那就是使用在线链接，一般都是用图床放图片，但是大部分图床都是收费的，所以我没有选择图床，而是使用了另外一个工具，那就是github，我们可以申请一个github专门放自己的图片，然后所有博客都使用图片的在线地址即可，现在简单为初学者介绍具体步骤： (1)、申请一个github小号，步骤和你申请博客的github帐号一样，注意邮箱不能和博客帐号的邮箱一样，我们可以申请一个qq小号用于接受github邮件 (2)、新建一个仓库，我创建的是ganmyxh.io，考虑到以后有可能会在这个仓库里面放html就这样创建，你如果只是放图片这里可以随便取名，点击Create repository (3)、进入仓库，复制仓库路径，如图 (4)、在桌面上新建一个文件夹，github_img,右键打开git，输入命令git clone 加你的的地址 (5)、进入目录ganmyxh.io，新建文件夹img,如图 (6)、把图片放到img目录里面，在git里面输入 1cd ganmyxh.io/ 然后输入 1git add . 说明一下，git add 后面那个.表示将你要提交的所有文件放到暂存区里面，然后依次输入下面两个命令 1git commit -m "提交图片" 1git push 这里会要你输入自己的用户名和密码，如图 (7)、进入我们的github，随便点到一张图片里面，右键-&gt;复制图片地址。注意不能复制网页上面的地址， 以后我们自己的博客图片地址都可以这样使用，就不用担心地址的问题了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[erlang项目流程查看技巧]]></title>
    <url>%2Ferlang_01.html</url>
    <content type="text"><![CDATA[在公司用过erlang一段时间，主要是用erlang来加密传输数据的，现在把我关于erlang的一点感悟写出来，现在erlanng项目基本框架都是用rebar生成的，所以大部分erlang项目都用一些类似的特点。 一般都有几个基本的的文件夹，如图： 先说说相关文件夹的作用： 1、bin主要是存放数据库的，因为公司项目主要是做手机银行后台的，具体内容我不能说，我们主要使用的数据库是mnesia,用于存放项目的相关数据。 2、config文件夹是用来存放配置文件的，比方说连接的ip地址 3、include文件夹是用来存放头文件的 4、ebin文件夹主要是放beam文件的，beam文件是erlang编译后生成的文件 5、log是存放报文的，分析问题的时候经常会使用报文 6、script文件夹是存放脚步文件的 7、用得最多的是src文件夹，我们写的erlang代码一般是放在里面 然后说先erlang项目的入口，向java和c都有main入口，erlang也有自己的入口，是一个后缀名为.app的文件，还是以网上比较出名的erlang项目远古封神来看，是用sublime text3找到server.app，这里面可以提供很多项目的相关信息，如图： 主要看mod对应的值yg_server_app,然后我们搜索yg_server_app.erl，这是我们的启动模块 在这里面有一个函数start就是我们的入口，如图 这个模块引用了两个头文件，common.hrl和record.hrl,这两个文件主要是存放一些我们经常会使用的常量的，关于启动函数，其他不管，我们找到yg_server_sup和yg_server这两个模块，先看yg_server_sup，这个模块主要是启动启动一个监控，关于erlang监控，可以看我的另外一篇博客，然后是yg_server这个模块，如图 这里面就是启动各种服务的地方了，我们随便看一个，比如跟客户端相关的服务，start_client(),如图 这里面也是各种开启监控树。]]></content>
      <categories>
        <category>erlang</category>
      </categories>
      <tags>
        <tag>erlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux上面安装配置mysql]]></title>
    <url>%2Flinux_mysql.html</url>
    <content type="text"><![CDATA[一个项目没有数据库可以说是无法想象的，作为一名开发人员，我们需要经常性的操作数据库。现在市面上有很多数据库可供我们使用，比如ACCESS，MSSQL，MYSQL，ORACLE，DB2,其中mysql可以说是目前最流行的数据库之一，mysql数据库主要有以下几个好处： 免费 跨平台 轻量级 支持多并发 mysql只有在linux运行环境下才能充分发挥其威力，在linux环境下搭建mysql就变得非常有意义了，下面我为大家详细介绍linux下mysql的搭建 下载mysql安装文件 有两个文件，分别是mysql-connector-java-5.1.6-bin.jar和mysql-standard-4.0.26-pc- linux-gnu-i686.tar.gz，点击下载 将两个安装文件拷贝到/home下,切换到root，输入命令： su root 不会从windows传文件到linux上？点这里传送 解压安装文件:1tar -zxvf mysql-standard-4.0.26-pc-linux-gnu-i686.tar.gz 解压缩后我们会得到一个目录如图 创建一个文件夹mysql :1mkdir mysql 移动文件到mysql里，输入命令:1mv mysql-standard-4.0.26-pc-linux-gnu-i686 mysql 创建一个组mysql注意这个命令要root权限才能使用，专门创建mysql组是为了方便以后管理mysql下面 的各个用户，输入命令: 1groupadd mysql 创建mysql用户放入mysql组，输入命令: 1useradd -g mysql mysql 进入mysql目录1cd mysql 初始化mysql数据库：1scripts/mysql_install_db --user=mysql 如图就是初始化成功： 修改权限 将mysql目录下所有文件以及子文件的所有者改为root、所在组改为mysql，输入命令： 1chown -R root:mysql . 注意后面有个点，表示使用当前路径，然后将数据文件夹用户改为mysql,输入命令： 1chown -R mysql data 我们检查一下是否成功改动，输入 1ls -l 结果如图所示： 后台运行mysql1bin/mysqld_safe --user=mysql &amp; 结果如图所示： 看看我们的mysql是否正常运行1netstat -anp | moe 看看3306端口是否存在，如图： 进入bin目录1cd bin 运行mysql1mysql -u root -p Enter password是要你输入密码，目前没有密码直接按enter即可，如图: ​ 现在mysql已经成功的安装到我们的linux下面了。到这里基本完成了，如果你想让以后的工作更方便，看看下面的内容。 现在我们打开mysql非常麻烦，需要进入/home/mysql/bin目录下执行，为了减少麻烦，我们可以将这个路径配置到环境变量里面，输入命令 1cd /root 1vi .bash_profile 改动如图 然后我们登出让配置文件生效，输入命令logout ，重新登录，现在你就可以在任意路径上运行mysql了。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux和windows之间传输文件]]></title>
    <url>%2Flinux_to_window.html</url>
    <content type="text"><![CDATA[​ 现在的开发流程一般都是在window上面写代码，然后在linux上面编译运行，但是windows和linux是不能直接传输文件的，下面我来详细的讲解linux与windows的传输，主要可以分为以下几步: 1、让window和linux互相ping通​ 首先确认我们的ip地址，在window上输入ipconfig，如图是我window上的ip地址 ​ ​ 然后在linux上输入ifconfig,如图所示 ​ ​ 这两个ip的网段不同，不能ping通，我们要改为一个网段，ip的前三个数字要相同，第四个数字不同，现在我将 ​ linux上的ip改为192.168.214.66，输入命令：ifconfig eth0 192.168.214.66，注意这个命令只能暂时改变ip， ​ 关闭linux就失效了。 ​ 现在我们重新ping就可以了，如图： ​ 2、关闭linux防火墙，输入命令：​ service iptables stop ​ 注意这个命令需要root权限，要先切换到root再使用，结果如图： ​ 3、如果你的系统是win7就要看这一步 ，不是的话可以直接跳过​ 在win7上我们要配置本地安全策略，在键盘上同时按win键和R键，win键就是ctrl和alt中间的那个键，输入 ​ secpol.msc ​ 如图： ​ ​ 找到本地策略-&gt;安全选项-&gt;网络安全：LAN管理器身份验证级别，把没有定义改为发送LM和NTLM-如果已协商，则使用NTLMV2会话安全，如图： 4、下载并安装SSH客户端，下载链接是：​ https://pan.baidu.com/s/173u4chFGQrgB3HJoTG1Cng ​ 密码是egc5 5、双击SshClient.exe打开，点击Quick connect，如图​ 6、填写参数Host Name是你的linux地址，User Name是你linux用户名，Port是对应的端口号，我们这里写22，如图： 接下来输入你root用户的密码即可 7、点击文件夹图标，如图： 8、现在你可以直接拖动文件到linux上了，如图 ​]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
